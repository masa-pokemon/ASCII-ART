<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ゼイジャックエストI - Security RPG</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        /* ドット絵風のフォントと基本スタイル */
        body {
            font-family: 'DotGothic16', monospace;
            background-color: #0f172a; /* Cyber World: Dark Slate */
            color: #e2e8f0; /* Light Text */
        }
        #gameCanvas {
            image-rendering: pixelated; /* ドット絵をきれいに表示 */
            border: 4px solid #3b82f6; /* Blue border for a digital feel */
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            margin: 0 auto;
        }
        /* RPGメニュー/ウィンドウ風スタイル */
        .rpg-window {
            background-color: rgba(30, 41, 59, 0.95); /* Darker, slightly transparent */
            border: 3px solid #60a5fa;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
        }
        .pixel-button {
            transition: transform 0.1s;
            box-shadow: 0 3px #1e40af;
        }
        .pixel-button:active {
            transform: translateY(2px);
            box-shadow: 0 1px #1e40af;
        }
        /* バトルメニュー用のスタイル */
        #combat-menu-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: auto; /* 高さを自動調整に変更 */
            min-height: 100px; /* 最小の高さを設定 */
            z-index: 10;
        }
        .menu-item {
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.1s;
            border-radius: 4px; /* 選択時の背景を見やすく */
            margin-bottom: 2px;
        }
        .menu-item.selected {
            background-color: #3b82f6; /* Blue selection */
            color: #0f172a;
        }
    </style>
    <!-- Firebase Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Firestoreログレベルをデバッグに設定
        setLogLevel('Debug');

        // グローバル変数
        window.initializeApp = initializeApp;
        window.getAuth = getAuth;
        window.signInAnonymously = signInAnonymously;
        window.signInWithCustomToken = signInWithCustomToken;
        window.onAuthStateChanged = onAuthStateChanged;
        window.getFirestore = getFirestore;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.onSnapshot = onSnapshot;
    </script>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- メインコンテナ -->
    <div class="max-w-4xl w-full">
        <h1 class="text-3xl font-bold text-center mb-6 text-yellow-400">ゼイジャックエストI <span class="text-sm text-cyan-300 block">~Cyber Security Saga~</span></h1>
        <div class="flex flex-col lg:flex-row gap-4">
            
            <!-- ゲーム画面コンテナ -->
            <div id="game-container" class="lg:w-3/4 flex justify-center relative">
                <canvas id="gameCanvas" width="512" height="512" class="w-full max-w-lg"></canvas>

                <!-- バトルUI要素: 敵ステータス -->
                <div id="enemy-status-box" class="rpg-window p-3 absolute top-4 left-4 w-64 hidden">
                    <h3 id="enemyName" class="text-lg text-red-400">--</h3>
                    <div class="mt-1">
                        <p class="text-xs">HP: <span id="enemyHpText">-- / --</span></p>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div id="enemyHpBar" class="h-2.5 rounded-full bg-red-600" style="width: 100%"></div>
                        </div>
                    </div>
                </div>

                <!-- バトルUI要素: コマンドメニュー -->
                <div id="combat-menu-box" class="rpg-window p-3 hidden">
                    <h3 class="text-yellow-300 text-lg mb-2 border-b border-gray-700 pb-1">コマンド</h3>
                    <div id="commandList" class="space-y-1">
                        <!-- コマンドアイテムはJSで挿入されます -->
                    </div>
                </div>
            </div>

            <!-- サイドバー/情報パネル -->
            <div class="lg:w-1/4">
                <div class="rpg-window p-4 mb-4">
                    <h2 class="text-xl text-yellow-300 border-b border-gray-500 pb-1 mb-2">現在の状況</h2>
                    <p id="playerJob" class="text-sm">職業: --</p>
                    <p id="playerLevel" class="text-sm">Lv: --</p>
                    <p id="playerHP" class="text-sm">HP: --</p>
                    <p id="statusMessage" class="text-sm text-green-400 mt-2 h-10 overflow-hidden">システム起動中...</p>
                    <p class="text-xs mt-3 text-gray-400">UserID: <span id="userIdDisplay">未認証</span></p>
                </div>
                
                <div class="rpg-window p-4">
                    <h2 class="text-xl text-yellow-300 border-b border-gray-500 pb-1 mb-2">操作方法</h2>
                    <ul class="list-disc list-inside text-sm space-y-1">
                        <li>移動/メニュー操作: <span class="text-blue-400">矢印キー</span></li>
                        <li>決定: <span class="text-blue-400">Enterキー</span></li>
                        <li>メニュー開閉: <span class="text-blue-400">Eキー</span></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- ゲーム内メッセージウィンドウ -->
        <div id="message-box" class="rpg-window p-4 mt-4 w-full h-24 flex items-center hidden">
            <p id="message-text" class="text-lg leading-relaxed"></p>
        </div>

    </div>

    <!-- Eキーメニューモーダル -->
    <div id="menuModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="rpg-window p-6 w-11/12 max-w-xl">
            <h2 class="text-2xl text-red-400 mb-4 border-b border-gray-500 pb-2">インベントリ・ステータス</h2>
            
            <div id="jobSelection" class="space-y-3 mb-6">
                <h3 class="text-lg text-yellow-300">職業選択 (最初のみ)</h3>
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="selectJob('ホワイトハッカー')" class="pixel-button bg-red-600 hover:bg-red-700 text-white font-bold py-2 rounded">ホワイトハッカー(勇者)</button>
                    <button onclick="selectJob('セキュリティエンジニア')" class="pixel-button bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded">S.E.(魔法使い)</button>
                    <button onclick="selectJob('ファイアウォール')" class="pixel-button bg-green-600 hover:bg-green-700 text-white font-bold py-2 rounded">FW(剣士)</button>
                    <button onclick="selectJob('フルスタック賢者')" class="pixel-button bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 rounded">フルスタック(賢者)</button>
                    <button onclick="selectJob('デバッガー')" class="pixel-button bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 rounded">デバッガー(魔物使い)</button>
                </div>
            </div>

            <div id="statsDisplay" class="mb-6 border p-3 border-gray-700 rounded">
                <h3 class="text-lg text-yellow-300 mb-2">ステータス</h3>
                <pre class="text-sm whitespace-pre-wrap font-mono" id="statusText">...</pre>
            </div>
            
            <div id="pikmonParty" class="mb-6 border p-3 border-gray-700 rounded">
                <h3 class="text-lg text-yellow-300 mb-2">仲間ピクモン</h3>
                <ul id="pikmonList" class="text-sm space-y-1">
                    <li>(まだ仲間はいません)</li>
                </ul>
            </div>

            <div class="flex justify-end space-x-3">
                <button onclick="saveGame()" class="pixel-button bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded">セーブ</button>
                <button onclick="closeMenu()" class="pixel-button bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">閉じる (E)</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        // --- Firebase Init ---
        let db;
        let auth;
        let userId = 'anonymous'; 

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const USER_DOC_PATH = (uid) => `artifacts/${appId}/users/${uid}/metadata/gameState`;

        let isAuthReady = false;

        async function initFirebase() {
            try {
                const app = window.initializeApp(firebaseConfig);
                db = window.getFirestore(app);
                auth = window.getAuth(app);

                if (initialAuthToken) {
                    await window.signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await window.signInAnonymously(auth);
                }

                window.onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('userIdDisplay').textContent = userId.substring(0, 8) + '...';
                        isAuthReady = true;
                        loadGame();
                    } else {
                        isAuthReady = true;
                        initGame();
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                isAuthReady = true;
                initGame();
            }
        }
        
        // --- ゲーム定数と変数 ---
        const TILE_SIZE = 32;
        const CANVAS_SIZE = 512;
        const MAP_COLS = CANVAS_SIZE / TILE_SIZE; // 16
        const MAP_ROWS = CANVAS_SIZE / TILE_SIZE; // 16
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // タイルタイプ
        const TILE_GROUND = 0; 
        const TILE_WALL = 1; 
        const TILE_GRASS = 2; 
        const TILE_START = 9; 

        // マップデータ (16x16)
        const gameMap = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 9, 0, 0, 2, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 2, 2, 0, 0, 0, 1, 0, 2, 2, 0, 2, 0, 1],
            [1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 1, 0, 2, 0, 1],
            [1, 0, 2, 0, 0, 0, 1, 2, 2, 2, 2, 1, 0, 2, 0, 1],
            [1, 0, 0, 0, 1, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],
            [1, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [1, 2, 1, 2, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        // 初期ステータス (セキュリティRPG風にアレンジ)
        const JOB_BASE_STATS = {
            'ホワイトハッカー': { str: 10, mag: 8, vit: 10, spd: 8, expRate: 1.5, desc: '攻守のバランスが良い。脆弱性診断が得意。' },
            'セキュリティエンジニア': { str: 4, mag: 12, vit: 6, spd: 9, expRate: 1.2, desc: '攻撃スクリプト(魔法)特化。論理防御は低いが火力は高い。' },
            'ファイアウォール': { str: 12, mag: 2, vit: 12, spd: 4, expRate: 1.1, desc: '物理遮断特化。圧倒的な防御力でパケットを防ぐ。' },
            'フルスタック賢者': { str: 5, mag: 15, vit: 7, spd: 7, expRate: 1.4, desc: '全レイヤー(魔法)大UP。あらゆるプロトコルに精通。' },
            'デバッガー': { str: 7, mag: 7, vit: 9, spd: 6, expRate: 0.8, desc: 'バグ(魔物)を手なずける。成長は遅いが、修正時のインパクト大。' },
        };

        const COMBAT_COMMANDS = ['パケット攻撃', 'スキル', '修復アイテム', 'ログアウト'];

        let gameState = {
            x: 0,
            y: 0,
            level: 1,
            job: '',
            exp: 0,
            maxHP: 50,
            currentHP: 50,
            stats: { str: 5, mag: 5, vit: 5, spd: 5 },
            pikmonParty: [], 
            isJobSelected: false,
            eventFlags: {}, // ストーリー進行用フラグ
            messageTimer: null,
            isMenuOpen: false,
            // --- バトルシステム用変数 ---
            mode: 'OVERWORLD', // 'OVERWORLD' or 'COMBAT'
            currentEnemy: null, // { name, maxHP, currentHP, level, type }
            selectedCommand: 0,
            combatLock: false,
        };

        // --- ゲーム初期化とメインループ ---
        function initGame() {
            // スタート地点の設定
            let startFound = false;
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    if (gameMap[y][x] === TILE_START) {
                        if (gameState.x === 0 && gameState.y === 0) { // 新規の場合のみ
                            gameState.x = x;
                            gameState.y = y;
                        }
                        startFound = true;
                        break;
                    }
                }
                if (startFound) break;
            }

            requestAnimationFrame(gameLoop);
        }

        function gameLoop() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            if (gameState.mode === 'OVERWORLD') {
                drawMap();
                drawPlayer();
            } else if (gameState.mode === 'COMBAT') {
                drawBattleScreen();
                document.getElementById('enemy-status-box').classList.remove('hidden');
                document.getElementById('combat-menu-box').classList.remove('hidden');
                renderCombatMenu();
            }

            updateStatusDisplay();
            
            if (!gameState.isMenuOpen) {
                requestAnimationFrame(gameLoop);
            }
        }
        
        // --- 描画処理 ---
        function drawTile(x, y, type) {
            // サイバーパンク風配色
            const colors = {
                [TILE_GROUND]: '#1e293b', // Dark Slate (Circuit Board base)
                [TILE_WALL]: '#475569',   // Lighter Slate (Firewall)
                [TILE_GRASS]: '#0f766e',  // Teal (Data Stream)
                [TILE_START]: '#1e293b'
            };
            
            ctx.fillStyle = colors[type] || '#000';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

            // グリッドライン
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

            // タイルごとの装飾
            if (type === TILE_GRASS) {
                ctx.fillStyle = '#2dd4bf'; // Bright Teal bits
                ctx.fillRect(x * TILE_SIZE + 8, y * TILE_SIZE + 8, 4, 4);
                ctx.fillRect(x * TILE_SIZE + 20, y * TILE_SIZE + 20, 4, 4);
            } else if (type === TILE_WALL) {
                ctx.strokeStyle = '#94a3b8';
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, y * TILE_SIZE);
                ctx.lineTo(x * TILE_SIZE + TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
                ctx.stroke();
            } else if (type === TILE_START) {
                ctx.fillStyle = '#3b82f6';
                ctx.font = '20px monospace';
                ctx.fillText('S', x * TILE_SIZE + 8, y * TILE_SIZE + 24);
            }
        }

        function drawPlayer() {
            const px = gameState.x * TILE_SIZE;
            const py = gameState.y * TILE_SIZE;
            // プレイヤーキャラ（カーソル風）
            ctx.fillStyle = '#facc15'; 
            ctx.beginPath();
            ctx.moveTo(px + 16, py + 4);
            ctx.lineTo(px + 28, py + 28);
            ctx.lineTo(px + 4, py + 28);
            ctx.fill();
        }

        function drawMap() {
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    drawTile(x, y, gameMap[y][x]);
                }
            }
        }

        function drawBattleScreen() {
            // バトル背景
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_SIZE);
            gradient.addColorStop(0, '#0f172a');
            gradient.addColorStop(1, '#1e1b4b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // デジタルグリッド
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)';
            ctx.lineWidth = 1;
            for(let i = 0; i < CANVAS_SIZE; i+=40) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(CANVAS_SIZE, i); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, CANVAS_SIZE); ctx.stroke();
            }

            if (gameState.currentEnemy) {
                const cx = CANVAS_SIZE / 2;
                const cy = CANVAS_SIZE / 3;

                // 敵のタイプに応じた描画
                const enemyColor = gameState.currentEnemy.isBoss ? '#ef4444' : // Boss: Red
                                   gameState.currentEnemy.type === 'ZeiJack' ? '#f97316' : // ZeiJack: Orange
                                   '#22c55e'; // Promon: Green
                
                // 敵の影
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + 80, 60, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // 敵本体
                ctx.fillStyle = enemyColor;
                ctx.beginPath();
                if (gameState.currentEnemy.isBoss) {
                    // ボスは大きくトゲトゲ
                    ctx.moveTo(cx, cy - 80);
                    ctx.lineTo(cx + 60, cy);
                    ctx.lineTo(cx + 40, cy + 80);
                    ctx.lineTo(cx - 40, cy + 80);
                    ctx.lineTo(cx - 60, cy);
                } else {
                    ctx.moveTo(cx, cy - 50);
                    ctx.lineTo(cx + 40, cy);
                    ctx.lineTo(cx + 20, cy + 60);
                    ctx.lineTo(cx - 20, cy + 60);
                    ctx.lineTo(cx - 40, cy);
                }
                ctx.closePath();
                ctx.fill();
                
                // 敵の目
                ctx.fillStyle = '#fff';
                ctx.fillRect(cx - 20, cy - 10, 10, 10);
                ctx.fillRect(cx + 10, cy - 10, 10, 10);

                // 名前表示
                ctx.font = '20px DotGothic16';
                ctx.fillStyle = '#fef08a';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.currentEnemy.name, cx, cy + 120);
            }
        }

        // --- 移動とイベント判定 ---
        const MOVEMENT_COOLDOWN = 150; 
        let lastMoveTime = 0;

        function mod(n, m) {
            return ((n % m) + m) % m;
        }

        function attemptMove(dx, dy) {
            if (!gameState.isJobSelected || gameState.isMenuOpen || gameState.mode === 'COMBAT') {
                if (!gameState.isJobSelected && !gameState.isMenuOpen) showMessage("Eキーでメニューを開き、職業(ロール)を選択してください。", 2000);
                return;
            }
            const now = Date.now();
            if (now - lastMoveTime < MOVEMENT_COOLDOWN) return;
            lastMoveTime = now;

            const nextX = gameState.x + dx;
            const nextY = gameState.y + dy;
            const newX = mod(nextX, MAP_COLS);
            const newY = mod(nextY, MAP_ROWS);

            const targetTile = gameMap[newY][newX];

            if (targetTile !== TILE_WALL) {
                gameState.x = newX; 
                gameState.y = newY;
                
                // イベントとエンカウントのチェック順序
                if (!checkStoryEvent(newX, newY)) {
                     if (targetTile === TILE_GRASS) {
                        checkEncounter();
                    }
                }
            }
        }
        
        // --- バトルシステム ---
        function checkEncounter() {
            if (Math.random() < 0.15 && !gameState.combatLock) { 
                initCombat();
            }
        }

        const ZEIJACK_NAMES = ['XSSスパイダー', 'SQLインジェクター', 'ブルートフォーサー', 'フィッシング詐欺師'];
        const PROMON_NAMES = ['迷子のパケット', '旧式ルーター', '未パッチサーバー'];
        
        function initCombat(bossData = null) {
            gameState.mode = 'COMBAT';
            gameState.selectedCommand = 0;
            gameState.combatLock = false;

            if (bossData) {
                gameState.currentEnemy = bossData;
                showMessage(`警告: ${bossData.name} が立ちはだかった！`, 4000);
            } else {
                const isZeiJack = Math.random() > 0.4;
                const enemyName = isZeiJack 
                    ? ZEIJACK_NAMES[Math.floor(Math.random() * ZEIJACK_NAMES.length)]
                    : PROMON_NAMES[Math.floor(Math.random() * PROMON_NAMES.length)];
                
                const enemyLevel = Math.max(1, gameState.level + Math.floor(Math.random() * 3) - 1);
                const baseHp = 25 + enemyLevel * 8;

                gameState.currentEnemy = {
                    name: enemyName,
                    maxHP: baseHp,
                    currentHP: baseHp,
                    level: enemyLevel,
                    type: isZeiJack ? 'ZeiJack' : 'Promon',
                    isBoss: false
                };
                showMessage(isZeiJack ? "不正なプロセスを検知！" : "中立なデータと遭遇。", 3000);
            }
            document.getElementById('menuModal').classList.add('hidden');
        }

        function endCombat(outcome) {
            const enemy = gameState.currentEnemy;
            gameState.mode = 'OVERWORLD';
            gameState.currentEnemy = null;
            gameState.combatLock = false;
            
            document.getElementById('enemy-status-box').classList.add('hidden');
            document.getElementById('combat-menu-box').classList.add('hidden');

            if (outcome === 'WIN') {
                const expGain = enemy.isBoss ? 500 : Math.floor(Math.random() * 20) + 10 * enemy.level;
                gameState.exp += expGain;
                showMessage(`脅威を排除した！ Exp+${expGain}`, 4000);
                if (enemy.isBoss) {
                    setTimeout(() => showMessage("「魔王エクスプロイト」は崩壊し、システムの制御権が戻った！ 世界に平和が訪れたのだ...", 10000), 4000);
                }
                checkLevelUp();
            } else if (outcome === 'LOSE') {
                showMessage("システムダウン... 再起動します。", 4000);
                gameState.currentHP = Math.floor(gameState.maxHP / 2);
                // スタート地点に戻す
                gameState.x = 1; gameState.y = 1; 
            } else if (outcome === 'ESCAPE') {
                showMessage("セッションを切断し、離脱しました。", 3000);
            }
            
            requestAnimationFrame(gameLoop);
        }

        function executeCommand(command) {
            if (gameState.combatLock) return;
            gameState.combatLock = true;
            
            switch (command) {
                case 'パケット攻撃': performAttack(); break;
                case 'スキル':
                    showMessage("スキルモジュールは未実装です。", 1500);
                    gameState.combatLock = false;
                    break;
                case '修復アイテム':
                    if (gameState.currentHP < gameState.maxHP) {
                        const heal = Math.floor(gameState.maxHP * 0.3);
                        gameState.currentHP = Math.min(gameState.maxHP, gameState.currentHP + heal);
                        showMessage(`パッチを適用。HPが${heal}回復した。`, 2000);
                        setTimeout(enemyTurn, 2500);
                    } else {
                        showMessage("システムは正常です。", 1500);
                        gameState.combatLock = false;
                    }
                    break;
                case 'ログアウト':
                    if (gameState.currentEnemy.isBoss) {
                        showMessage("管理者権限によりログアウトできません！", 2000);
                        setTimeout(() => gameState.combatLock = false, 2000);
                    } else {
                        performEscape();
                    }
                    break;
            }
        }
        
        function performAttack() {
            const crit = Math.random() < 0.1 ? 2 : 1;
            const damage = Math.floor(Math.max(1, gameState.stats.str * 1.5 - (gameState.currentEnemy.level * 0.5)) * crit);
            
            showMessage(`攻撃パケット送信... ${crit > 1 ? "クリティカル！" : ""} ${gameState.currentEnemy.name}に${damage}ダメージ！`, 3000);
            gameState.currentEnemy.currentHP -= damage;
            
            if (gameState.currentEnemy.currentHP <= 0) {
                gameState.currentEnemy.currentHP = 0;
                setTimeout(() => endCombat('WIN'), 3500);
            } else {
                setTimeout(enemyTurn, 4000);
            }
        }
        
        function performEscape() {
            const chance = gameState.stats.spd / (gameState.currentEnemy.level * 5 + 10);
            if (Math.random() < chance + 0.5) { // 逃げやすく調整
                setTimeout(() => endCombat('ESCAPE'), 1000);
            } else {
                showMessage("接続を切断できない！", 2000);
                setTimeout(enemyTurn, 2500);
            }
        }

        function enemyTurn() {
            const enemy = gameState.currentEnemy;
            const damage = Math.floor(Math.max(0, enemy.level * 2 + 5 - gameState.stats.vit / 2));
            
            gameState.currentHP -= damage;
            showMessage(`${enemy.name}の反撃！ ${damage}のダメージを受けた！`, 3000);

            if (gameState.currentHP <= 0) {
                gameState.currentHP = 0;
                setTimeout(() => endCombat('LOSE'), 3500);
            } else {
                setTimeout(() => gameState.combatLock = false, 3500);
            }
        }

        function checkLevelUp() {
            const expNeeded = gameState.level * 100 * 1.2;
            if (gameState.exp >= expNeeded) {
                gameState.level++;
                gameState.exp = 0; 
                
                const job = JOB_BASE_STATS[gameState.job] || {str:2, mag:2, vit:2, spd:2};
                gameState.stats.str += Math.ceil(job.str / 3);
                gameState.stats.mag += Math.ceil(job.mag / 3);
                gameState.stats.vit += Math.ceil(job.vit / 3);
                gameState.stats.spd += Math.ceil(job.spd / 3);
                
                gameState.maxHP += 10 + Math.floor(job.vit / 2);
                gameState.currentHP = gameState.maxHP;

                showMessage(`レベルアップ！ Lv${gameState.level}になり、システム性能が向上しました。`, 5000);
            }
        }
        
        // --- ストーリーイベントシステム ---
        function checkStoryEvent(x, y) {
            // ユニークキーでイベント管理
            const locKey = `${x},${y}`;
            
            // 1. スタート地点 (チュートリアル)
            if (gameMap[y][x] === TILE_START && !gameState.eventFlags['START_TUTORIAL']) {
                gameState.eventFlags['START_TUTORIAL'] = true;
                showMessage("【システムログ】認証完了。ネットワーク内の脆弱性を特定し、パッチを適用せよ。右下の『ルートディレクトリ』を目指してください。", 10000);
                return true;
            }

            // 2. 中間地点 (8, 8) 付近
            if (x === 8 && y === 8 && !gameState.eventFlags['MID_WARNING']) {
                gameState.eventFlags['MID_WARNING'] = true;
                showMessage("【警告】このセクターはデータ破損が激しい。DoS攻撃の痕跡があります。慎重に進んでください。", 8000);
                return true;
            }

            // 3. 隠しポイント (3, 12) - セキュリティネタ
            if (x === 3 && y === 12 && !gameState.eventFlags['SECRET_CACHE']) {
                gameState.eventFlags['SECRET_CACHE'] = true;
                gameState.exp += 50;
                showMessage("【発見】古いキャッシュデータを発見。「password123」...脆弱なパスワードだ。経験値+50", 6000);
                return true;
            }

            // 4. ボス戦トリガー (14, 14)
            if (x === 14 && y === 14) {
                if (!gameState.eventFlags['BOSS_DEFEATED']) {
                    initCombat({
                        name: '魔王エクスプロイト',
                        maxHP: 300,
                        currentHP: 300,
                        level: 20,
                        type: 'ZeiJack',
                        isBoss: true
                    });
                    return true;
                } else {
                    showMessage("ここは浄化されたルートディレクトリだ。平和なパケットが流れている。", 4000);
                    return true;
                }
            }
            
            return false;
        }

        function showMessage(text, duration = 3000) {
            clearTimeout(gameState.messageTimer);
            const box = document.getElementById('message-box');
            const p = document.getElementById('message-text');
            
            p.textContent = text;
            box.classList.remove('hidden');
            
            // ログの色分け（簡易的）
            if (text.includes("警告") || text.includes("ダメージ") || text.includes("魔王")) {
                p.className = "text-lg leading-relaxed text-red-300";
            } else if (text.includes("発見") || text.includes("レベルアップ") || text.includes("勝利")) {
                p.className = "text-lg leading-relaxed text-yellow-300";
            } else {
                p.className = "text-lg leading-relaxed text-green-300";
            }
            
            gameState.messageTimer = setTimeout(() => {
                box.classList.add('hidden');
            }, duration);
        }

        function updateStatusDisplay() {
            document.getElementById('playerJob').textContent = `${gameState.job || '未定義'}`;
            document.getElementById('playerLevel').textContent = `Lv: ${gameState.level}`;
            document.getElementById('playerHP').textContent = `HP: ${gameState.currentHP} / ${gameState.maxHP}`;
            
            if (gameState.mode === 'COMBAT' && gameState.currentEnemy) {
                const enemy = gameState.currentEnemy;
                document.getElementById('enemyName').textContent = `${enemy.name}`;
                document.getElementById('enemyHpText').textContent = `${enemy.currentHP} / ${enemy.maxHP}`;
                document.getElementById('enemyHpBar').style.width = `${(enemy.currentHP / enemy.maxHP) * 100}%`;
            }

            const statsText = `
Lv: ${gameState.level} (${gameState.job})
HP: ${gameState.currentHP}/${gameState.maxHP}
EXP: ${gameState.exp}

STR: ${gameState.stats.str} | MAG: ${gameState.stats.mag}
VIT: ${gameState.stats.vit} | SPD: ${gameState.stats.spd}

[ロール特性]
${JOB_BASE_STATS[gameState.job]?.desc || '未選択'}
            `.trim();
            document.getElementById('statusText').textContent = statsText;

            document.getElementById('jobSelection').classList.toggle('hidden', gameState.isJobSelected);
        }

        function renderCombatMenu() {
            const list = document.getElementById('commandList');
            list.innerHTML = '';
            COMBAT_COMMANDS.forEach((cmd, idx) => {
                const div = document.createElement('div');
                div.className = `menu-item ${idx === gameState.selectedCommand ? 'selected' : 'text-white'}`;
                div.textContent = cmd;
                div.onclick = () => executeCommand(cmd);
                list.appendChild(div);
            });
        }

        // --- 入力ハンドリング ---
        window.openMenu = function() {
            if (!isAuthReady || gameState.mode === 'COMBAT') return;
            gameState.isMenuOpen = true;
            document.getElementById('menuModal').classList.remove('hidden');
            updateStatusDisplay();
        }

        window.closeMenu = function() {
            gameState.isMenuOpen = false;
            document.getElementById('menuModal').classList.add('hidden');
            requestAnimationFrame(gameLoop);
        }

        window.selectJob = function(jobName) {
            if (gameState.isJobSelected) return;
            gameState.job = jobName;
            gameState.isJobSelected = true;
            gameState.stats = { ...JOB_BASE_STATS[jobName] };
            gameState.maxHP = 40 + gameState.stats.vit * 2;
            gameState.currentHP = gameState.maxHP;
            showMessage(`ロール: ${jobName} をインストールしました。`, 4000);
            updateStatusDisplay();
        }

        document.addEventListener('keydown', (e) => {
            if (gameState.isMenuOpen) {
                if (e.key === 'e' || e.key === 'E') window.closeMenu();
                return;
            }
            
            if (gameState.mode === 'OVERWORLD') {
                if (e.key === 'ArrowUp') attemptMove(0, -1);
                if (e.key === 'ArrowDown') attemptMove(0, 1);
                if (e.key === 'ArrowLeft') attemptMove(-1, 0);
                if (e.key === 'ArrowRight') attemptMove(1, 0);
                if (e.key === 'e' || e.key === 'E') window.openMenu();
            } else if (gameState.mode === 'COMBAT' && !gameState.combatLock) {
                if (e.key === 'ArrowUp') gameState.selectedCommand = Math.max(0, gameState.selectedCommand - 1);
                if (e.key === 'ArrowDown') gameState.selectedCommand = Math.min(COMBAT_COMMANDS.length - 1, gameState.selectedCommand + 1);
                if (e.key === 'Enter') executeCommand(COMBAT_COMMANDS[gameState.selectedCommand]);
                renderCombatMenu();
            }
        });

        // --- Save/Load ---
        window.saveGame = async function() {
            if (!isAuthReady || !userId || !db || !gameState.isJobSelected) {
                showMessage("エラー: 認証またはロール選択が未完了です。", 3000);
                return;
            }
            try {
                const saveState = { 
                    x: gameState.x, y: gameState.y, level: gameState.level, job: gameState.job,
                    exp: gameState.exp, maxHP: gameState.maxHP, currentHP: gameState.currentHP,
                    stats: gameState.stats, pikmonParty: gameState.pikmonParty, 
                    isJobSelected: gameState.isJobSelected, eventFlags: gameState.eventFlags
                };
                await window.setDoc(window.doc(db, USER_DOC_PATH(userId)), saveState);
                showMessage("システム状態をバックアップしました。", 3000);
            } catch (error) {
                console.error("Save error:", error);
                showMessage("バックアップに失敗しました。", 3000);
            }
        }

        async function loadGame() {
            if (!isAuthReady || !userId || !db) return;
            try {
                const snap = await window.getDoc(window.doc(db, USER_DOC_PATH(userId)));
                if (snap.exists()) {
                    const data = snap.data();
                    Object.assign(gameState, data);
                    gameState.mode = 'OVERWORLD';
                    showMessage("バックアップから復元しました。", 4000);
                } else {
                    // 初回プロローグ
                    setTimeout(() => {
                         showMessage("【プロローグ】時は2045年。電脳空間は未知のウイルス「ゼイジャック」により汚染されていた。", 6000);
                    }, 1000);
                }
            } catch (error) {
                console.error("Load error:", error);
            }
            initGame();
        }

        window.onload = function() {
            initFirebase();
        };
    </script>
</body>
</html>
