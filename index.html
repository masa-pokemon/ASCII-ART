<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ゼイジャックエストI - Local Storage Ver.</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');

        /* ドット絵風のフォントと基本スタイル */
        body {
            font-family: 'DotGothic16', monospace;
            background-color: #0f172a; /* Cyber World: Dark Slate */
            color: #e2e8f0; /* Light Text */
            overflow: hidden; /* スクロール防止 */
        }
        #gameCanvas {
            image-rendering: pixelated;
            border: 4px solid #3b82f6;
            box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            margin: 0 auto;
            background-color: #000;
        }
        /* RPGメニュー/ウィンドウ風スタイル */
        .rpg-window {
            background-color: rgba(30, 41, 59, 0.95);
            border: 3px solid #60a5fa;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.7);
        }
        .pixel-button {
            transition: transform 0.1s;
            box-shadow: 0 3px #1e40af;
            border: 2px solid #60a5fa; 
            background-color: #1e3a8a;
            color: white;
            text-align: center;
            cursor: pointer;
        }
        .pixel-button:hover {
            background-color: #2563eb;
        }
        .pixel-button:active {
            transform: translateY(2px);
            box-shadow: 0 1px #1e40af;
        }
        /* バトルメニュー用のスタイル */
        #combat-menu-box {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: auto;
            min-height: 100px;
            z-index: 10;
        }
        .menu-item {
            padding: 8px;
            cursor: pointer;
            transition: background-color 0.1s;
            border-radius: 4px;
            margin-bottom: 2px;
        }
        .menu-item.selected {
            background-color: #3b82f6;
            color: #0f172a;
        }
        /* スロットボタンスタイル */
        .slot-button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 12px;
            margin-bottom: 8px;
            border: 2px solid #475569;
            background: #1e293b;
            color: #94a3b8;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .slot-button:hover:not(:disabled) {
            border-color: #3b82f6;
            background: #334155;
            color: #fff;
        }
        .slot-button.empty {
            color: #64748b;
            font-style: italic;
        }
        .slot-info {
            font-size: 0.9em;
            color: #cbd5e1;
        }
        .slot-date {
            font-size: 0.75em;
            color: #94a3b8;
            float: right;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen p-4">

    <!-- タイトル画面 -->
    <div id="title-screen" class="fixed inset-0 z-50 flex flex-col items-center justify-center bg-slate-900">
        <h1 class="text-5xl font-bold text-yellow-400 mb-2 tracking-widest drop-shadow-lg">ZeiJack Quest I</h1>
        <p class="text-cyan-400 mb-12 text-lg tracking-wide">~ Cyber Security Saga ~</p>
        
        <div class="space-y-4 w-64">
            <button onclick="startNewGame()" class="pixel-button w-full py-4 text-xl font-bold rounded">NEW GAME</button>
            <button onclick="openSaveLoadMenu('load')" class="pixel-button w-full py-4 text-xl font-bold rounded">LOAD GAME</button>
        </div>
        <p class="absolute bottom-4 text-slate-500 text-xs">Local Storage Version</p>
    </div>

    <!-- メインコンテナ -->
    <div id="main-container" class="max-w-4xl w-full hidden">
        <div class="flex justify-between items-end mb-2">
            <h1 class="text-2xl font-bold text-yellow-400">ゼイジャックエストI</h1>
            <button onclick="returnToTitle()" class="text-xs text-gray-400 hover:text-white underline">タイトルへ戻る</button>
        </div>
        
        <div class="flex flex-col lg:flex-row gap-4">
            
            <!-- ゲーム画面コンテナ -->
            <div id="game-container" class="lg:w-3/4 flex justify-center relative">
                <canvas id="gameCanvas" width="512" height="512" class="w-full max-w-lg"></canvas>

                <!-- バトルUI要素: 敵ステータス -->
                <div id="enemy-status-box" class="rpg-window p-3 absolute top-4 left-4 w-64 hidden">
                    <h3 id="enemyName" class="text-lg text-red-400">--</h3>
                    <div class="mt-1">
                        <p class="text-xs">HP: <span id="enemyHpText">-- / --</span></p>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div id="enemyHpBar" class="h-2.5 rounded-full bg-red-600" style="width: 100%"></div>
                        </div>
                    </div>
                </div>

                <!-- バトルUI要素: コマンドメニュー -->
                <div id="combat-menu-box" class="rpg-window p-3 hidden">
                    <h3 class="text-yellow-300 text-lg mb-2 border-b border-gray-700 pb-1">コマンド</h3>
                    <div id="commandList" class="space-y-1">
                        <!-- コマンドアイテムはJSで挿入されます -->
                    </div>
                </div>
            </div>

            <!-- サイドバー/情報パネル -->
            <div class="lg:w-1/4">
                <div class="rpg-window p-4 mb-4">
                    <h2 class="text-xl text-yellow-300 border-b border-gray-500 pb-1 mb-2">現在の状況</h2>
                    <p id="playerJob" class="text-sm">職業: --</p>
                    <p id="playerLevel" class="text-sm">Lv: --</p>
                    <p id="playerHP" class="text-sm">HP: --</p>
                    <p id="statusMessage" class="text-sm text-green-400 mt-2 h-10 overflow-hidden">システム起動中...</p>
                </div>
                
                <div class="rpg-window p-4">
                    <h2 class="text-xl text-yellow-300 border-b border-gray-500 pb-1 mb-2">操作方法</h2>
                    <ul class="list-disc list-inside text-sm space-y-1">
                        <li>移動/メニュー操作: <span class="text-blue-400">矢印キー</span></li>
                        <li>決定: <span class="text-blue-400">Enterキー</span></li>
                        <li>メニュー開閉: <span class="text-blue-400">Eキー</span></li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- ゲーム内メッセージウィンドウ -->
        <div id="message-box" class="rpg-window p-4 mt-4 w-full h-24 flex items-center hidden">
            <p id="message-text" class="text-lg leading-relaxed"></p>
        </div>

    </div>

    <!-- Eキーメニューモーダル -->
    <div id="menuModal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-40 hidden">
        <div class="rpg-window p-6 w-11/12 max-w-xl relative">
            <h2 class="text-2xl text-red-400 mb-4 border-b border-gray-500 pb-2">メニュー</h2>
            
            <div id="jobSelection" class="space-y-3 mb-6 hidden">
                <h3 class="text-lg text-yellow-300">職業選択 (最初のみ)</h3>
                <div class="grid grid-cols-2 gap-3">
                    <button onclick="selectJob('ホワイトハッカー')" class="pixel-button bg-red-600 hover:bg-red-700 font-bold py-2 rounded">ホワイトハッカー(勇者)</button>
                    <button onclick="selectJob('セキュリティエンジニア')" class="pixel-button bg-blue-600 hover:bg-blue-700 font-bold py-2 rounded">S.E.(魔法使い)</button>
                    <button onclick="selectJob('ファイアウォール')" class="pixel-button bg-green-600 hover:bg-green-700 font-bold py-2 rounded">FW(剣士)</button>
                    <button onclick="selectJob('フルスタック賢者')" class="pixel-button bg-purple-600 hover:bg-purple-700 font-bold py-2 rounded">フルスタック(賢者)</button>
                    <button onclick="selectJob('デバッガー')" class="pixel-button bg-yellow-600 hover:bg-yellow-700 font-bold py-2 rounded">デバッガー(魔物使い)</button>
                </div>
            </div>

            <div id="statsDisplay" class="mb-6 border p-3 border-gray-700 rounded">
                <h3 class="text-lg text-yellow-300 mb-2">ステータス</h3>
                <pre class="text-sm whitespace-pre-wrap font-mono" id="statusText">...</pre>
            </div>
            
            <div class="flex justify-end space-x-3">
                <button onclick="openSaveLoadMenu('save')" class="pixel-button bg-indigo-600 hover:bg-indigo-700 py-2 px-4 rounded">セーブ</button>
                <button onclick="closeMenu()" class="pixel-button bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded">閉じる (E)</button>
            </div>
        </div>
    </div>

    <!-- セーブ/ロード選択モーダル -->
    <div id="save-load-modal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50 hidden">
        <div class="rpg-window p-6 w-96">
            <h2 id="sl-modal-title" class="text-2xl text-white mb-4 border-b border-gray-500 pb-2">セーブデータ選択</h2>
            <div id="save-slots" class="space-y-2 mb-4">
                <!-- スロットボタンはJSで生成 -->
            </div>
            <div class="flex justify-end">
                <button onclick="closeSaveLoadMenu()" class="pixel-button bg-gray-600 hover:bg-gray-700 py-2 px-4 rounded">キャンセル</button>
            </div>
        </div>
    </div>
    
    <script>
        // --- ゲーム定数と変数 ---
        const TILE_SIZE = 32;
        const CANVAS_SIZE = 512;
        const MAP_COLS = CANVAS_SIZE / TILE_SIZE; // 16
        const MAP_ROWS = CANVAS_SIZE / TILE_SIZE; // 16
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const TILE_GROUND = 0; 
        const TILE_WALL = 1; 
        const TILE_GRASS = 2; 
        const TILE_START = 9; 

        // マップデータ (16x16)
        const gameMap = [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 9, 0, 0, 2, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 2, 2, 0, 0, 0, 1, 0, 2, 2, 0, 2, 0, 1],
            [1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 1, 0, 2, 0, 1],
            [1, 0, 2, 0, 0, 0, 1, 2, 2, 2, 2, 1, 0, 2, 0, 1],
            [1, 0, 0, 0, 1, 0, 1, 2, 1, 1, 1, 1, 0, 0, 0, 1],
            [1, 0, 1, 1, 1, 0, 1, 2, 2, 2, 0, 0, 0, 1, 0, 1],
            [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1],
            [1, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1],
            [1, 2, 1, 2, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
            [1, 0, 1, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 1],
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        ];

        const JOB_BASE_STATS = {
            'ホワイトハッカー': { str: 10, mag: 8, vit: 10, spd: 8, expRate: 1.5, desc: '攻守のバランスが良い。脆弱性診断が得意。' },
            'セキュリティエンジニア': { str: 4, mag: 12, vit: 6, spd: 9, expRate: 1.2, desc: '攻撃スクリプト(魔法)特化。論理防御は低いが火力は高い。' },
            'ファイアウォール': { str: 12, mag: 2, vit: 12, spd: 4, expRate: 1.1, desc: '物理遮断特化。圧倒的な防御力でパケットを防ぐ。' },
            'フルスタック賢者': { str: 5, mag: 15, vit: 7, spd: 7, expRate: 1.4, desc: '全レイヤー(魔法)大UP。あらゆるプロトコルに精通。' },
            'デバッガー': { str: 7, mag: 7, vit: 9, spd: 6, expRate: 0.8, desc: 'バグ(魔物)を手なずける。成長は遅いが、修正時のインパクト大。' },
        };

        const COMBAT_COMMANDS = ['パケット攻撃', 'スキル', '修復アイテム', 'ログアウト'];

        // 初期状態テンプレート
        const INITIAL_GAME_STATE = {
            x: 0, y: 0, level: 1, job: '', exp: 0,
            maxHP: 50, currentHP: 50,
            stats: { str: 5, mag: 5, vit: 5, spd: 5 },
            pikmonParty: [], isJobSelected: false,
            eventFlags: {},
            mode: 'OVERWORLD',
            currentEnemy: null,
            selectedCommand: 0,
            combatLock: false,
        };

        let gameState = JSON.parse(JSON.stringify(INITIAL_GAME_STATE));
        let messageTimer = null;
        let isMenuOpen = false;
        let isGameLoopRunning = false;

        // --- 描画システム ---
        function drawTile(x, y, type) {
            const colors = {
                [TILE_GROUND]: '#1e293b',
                [TILE_WALL]: '#475569',
                [TILE_GRASS]: '#0f766e',
                [TILE_START]: '#1e293b'
            };
            ctx.fillStyle = colors[type] || '#000';
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);

            if (type === TILE_GRASS) {
                ctx.fillStyle = '#2dd4bf';
                ctx.fillRect(x * TILE_SIZE + 8, y * TILE_SIZE + 8, 4, 4);
                ctx.fillRect(x * TILE_SIZE + 20, y * TILE_SIZE + 20, 4, 4);
            } else if (type === TILE_WALL) {
                ctx.strokeStyle = '#94a3b8';
                ctx.beginPath();
                ctx.moveTo(x * TILE_SIZE, y * TILE_SIZE);
                ctx.lineTo(x * TILE_SIZE + TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
                ctx.stroke();
            } else if (type === TILE_START) {
                ctx.fillStyle = '#3b82f6';
                ctx.font = '20px monospace';
                ctx.fillText('S', x * TILE_SIZE + 8, y * TILE_SIZE + 24);
            }
        }

        function drawPlayer() {
            const px = gameState.x * TILE_SIZE;
            const py = gameState.y * TILE_SIZE;
            ctx.fillStyle = '#facc15'; 
            ctx.beginPath();
            ctx.moveTo(px + 16, py + 4);
            ctx.lineTo(px + 28, py + 28);
            ctx.lineTo(px + 4, py + 28);
            ctx.fill();
        }

        function drawMap() {
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    drawTile(x, y, gameMap[y][x]);
                }
            }
        }

        function drawBattleScreen() {
            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_SIZE);
            gradient.addColorStop(0, '#0f172a');
            gradient.addColorStop(1, '#1e1b4b');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            ctx.strokeStyle = 'rgba(56, 189, 248, 0.2)';
            ctx.lineWidth = 1;
            for(let i = 0; i < CANVAS_SIZE; i+=40) {
                ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(CANVAS_SIZE, i); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, CANVAS_SIZE); ctx.stroke();
            }

            if (gameState.currentEnemy) {
                const cx = CANVAS_SIZE / 2;
                const cy = CANVAS_SIZE / 3;
                const enemyColor = gameState.currentEnemy.isBoss ? '#ef4444' : 
                                   gameState.currentEnemy.type === 'ZeiJack' ? '#f97316' : '#22c55e';
                
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + 80, 60, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = enemyColor;
                ctx.beginPath();
                if (gameState.currentEnemy.isBoss) {
                    ctx.moveTo(cx, cy - 80);
                    ctx.lineTo(cx + 60, cy);
                    ctx.lineTo(cx + 40, cy + 80);
                    ctx.lineTo(cx - 40, cy + 80);
                    ctx.lineTo(cx - 60, cy);
                } else {
                    ctx.moveTo(cx, cy - 50);
                    ctx.lineTo(cx + 40, cy);
                    ctx.lineTo(cx + 20, cy + 60);
                    ctx.lineTo(cx - 20, cy + 60);
                    ctx.lineTo(cx - 40, cy);
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.fillRect(cx - 20, cy - 10, 10, 10);
                ctx.fillRect(cx + 10, cy - 10, 10, 10);

                ctx.font = '20px DotGothic16';
                ctx.fillStyle = '#fef08a';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.currentEnemy.name, cx, cy + 120);
            }
        }

        // --- ゲームループ ---
        function initGame() {
            let startFound = false;
            for (let y = 0; y < MAP_ROWS; y++) {
                for (let x = 0; x < MAP_COLS; x++) {
                    if (gameMap[y][x] === TILE_START) {
                        if (gameState.x === 0 && gameState.y === 0) {
                            gameState.x = x;
                            gameState.y = y;
                        }
                        startFound = true;
                        break;
                    }
                }
                if (startFound) break;
            }
            
            if (!gameState.isJobSelected) {
                setTimeout(() => showMessage("Eキーでメニューを開き、職業(ロール)を選択してください。", 3000), 1000);
            }
            
            if (!isGameLoopRunning) {
                isGameLoopRunning = true;
                requestAnimationFrame(gameLoop);
            }
        }

        function gameLoop() {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            
            if (gameState.mode === 'OVERWORLD') {
                drawMap();
                drawPlayer();
            } else if (gameState.mode === 'COMBAT') {
                drawBattleScreen();
                document.getElementById('enemy-status-box').classList.remove('hidden');
                document.getElementById('combat-menu-box').classList.remove('hidden');
                renderCombatMenu();
            }

            updateStatusDisplay();
            
            if (isGameLoopRunning && !gameState.isMenuOpen) {
                requestAnimationFrame(gameLoop);
            }
        }

        // --- 移動とイベント ---
        const MOVEMENT_COOLDOWN = 150; 
        let lastMoveTime = 0;

        function attemptMove(dx, dy) {
            if (!gameState.isJobSelected || gameState.isMenuOpen || gameState.mode === 'COMBAT') {
                if (!gameState.isJobSelected && !gameState.isMenuOpen) showMessage("Eキーでメニューを開き、職業(ロール)を選択してください。", 2000);
                return;
            }
            const now = Date.now();
            if (now - lastMoveTime < MOVEMENT_COOLDOWN) return;
            lastMoveTime = now;

            const nextX = (gameState.x + dx + MAP_COLS) % MAP_COLS;
            const nextY = (gameState.y + dy + MAP_ROWS) % MAP_ROWS;

            const targetTile = gameMap[nextY][nextX];

            if (targetTile !== TILE_WALL) {
                gameState.x = nextX; 
                gameState.y = nextY;
                if (!checkStoryEvent(nextX, nextY)) {
                     if (targetTile === TILE_GRASS) {
                        checkEncounter();
                    }
                }
            }
        }
        
        // --- バトルロジック ---
        const ZEIJACK_NAMES = ['XSSスパイダー', 'SQLインジェクター', 'ブルートフォーサー', 'フィッシング詐欺師'];
        const PROMON_NAMES = ['迷子のパケット', '旧式ルーター', '未パッチサーバー'];

        function checkEncounter() {
            if (Math.random() < 0.15 && !gameState.combatLock) { 
                initCombat();
            }
        }

        function initCombat(bossData = null) {
            gameState.mode = 'COMBAT';
            gameState.selectedCommand = 0;
            gameState.combatLock = false;

            if (bossData) {
                gameState.currentEnemy = bossData;
                showMessage(`警告: ${bossData.name} が立ちはだかった！`, 4000);
            } else {
                const isZeiJack = Math.random() > 0.4;
                const enemyName = isZeiJack 
                    ? ZEIJACK_NAMES[Math.floor(Math.random() * ZEIJACK_NAMES.length)]
                    : PROMON_NAMES[Math.floor(Math.random() * PROMON_NAMES.length)];
                
                const enemyLevel = Math.max(1, gameState.level + Math.floor(Math.random() * 3) - 1);
                const baseHp = 25 + enemyLevel * 8;

                gameState.currentEnemy = {
                    name: enemyName,
                    maxHP: baseHp,
                    currentHP: baseHp,
                    level: enemyLevel,
                    type: isZeiJack ? 'ZeiJack' : 'Promon',
                    isBoss: false
                };
                showMessage(isZeiJack ? "不正なプロセスを検知！" : "中立なデータと遭遇。", 3000);
            }
            document.getElementById('menuModal').classList.add('hidden');
        }

        function endCombat(outcome) {
            const enemy = gameState.currentEnemy;
            gameState.mode = 'OVERWORLD';
            gameState.currentEnemy = null;
            gameState.combatLock = false;
            
            document.getElementById('enemy-status-box').classList.add('hidden');
            document.getElementById('combat-menu-box').classList.add('hidden');

            if (outcome === 'WIN') {
                const expGain = enemy.isBoss ? 500 : Math.floor(Math.random() * 20) + 10 * enemy.level;
                gameState.exp += expGain;
                showMessage(`脅威を排除した！ Exp+${expGain}`, 4000);
                if (enemy.isBoss) {
                    setTimeout(() => showMessage("「魔王エクスプロイト」は崩壊し、システムの制御権が戻った！ 世界に平和が訪れたのだ...", 10000), 4000);
                }
                checkLevelUp();
            } else if (outcome === 'LOSE') {
                showMessage("システムダウン... 再起動します。", 4000);
                gameState.currentHP = Math.floor(gameState.maxHP / 2);
                gameState.x = 1; gameState.y = 1; 
            } else if (outcome === 'ESCAPE') {
                showMessage("セッションを切断し、離脱しました。", 3000);
            }
        }

        function executeCommand(command) {
            if (gameState.combatLock) return;
            gameState.combatLock = true;
            
            switch (command) {
                case 'パケット攻撃': performAttack(); break;
                case 'スキル':
                    showMessage("スキルモジュールは未実装です。", 1500);
                    gameState.combatLock = false;
                    break;
                case '修復アイテム':
                    if (gameState.currentHP < gameState.maxHP) {
                        const heal = Math.floor(gameState.maxHP * 0.3);
                        gameState.currentHP = Math.min(gameState.maxHP, gameState.currentHP + heal);
                        showMessage(`パッチを適用。HPが${heal}回復した。`, 2000);
                        setTimeout(enemyTurn, 2500);
                    } else {
                        showMessage("システムは正常です。", 1500);
                        gameState.combatLock = false;
                    }
                    break;
                case 'ログアウト':
                    if (gameState.currentEnemy.isBoss) {
                        showMessage("管理者権限によりログアウトできません！", 2000);
                        setTimeout(() => gameState.combatLock = false, 2000);
                    } else {
                        const chance = gameState.stats.spd / (gameState.currentEnemy.level * 5 + 10);
                        if (Math.random() < chance + 0.5) {
                            setTimeout(() => endCombat('ESCAPE'), 1000);
                        } else {
                            showMessage("接続を切断できない！", 2000);
                            setTimeout(enemyTurn, 2500);
                        }
                    }
                    break;
            }
        }
        
        function performAttack() {
            const crit = Math.random() < 0.1 ? 2 : 1;
            const damage = Math.floor(Math.max(1, gameState.stats.str * 1.5 - (gameState.currentEnemy.level * 0.5)) * crit);
            
            showMessage(`攻撃パケット送信... ${crit > 1 ? "クリティカル！" : ""} ${gameState.currentEnemy.name}に${damage}ダメージ！`, 3000);
            gameState.currentEnemy.currentHP -= damage;
            
            if (gameState.currentEnemy.currentHP <= 0) {
                gameState.currentEnemy.currentHP = 0;
                setTimeout(() => endCombat('WIN'), 3500);
            } else {
                setTimeout(enemyTurn, 4000);
            }
        }

        function enemyTurn() {
            const enemy = gameState.currentEnemy;
            const damage = Math.floor(Math.max(0, enemy.level * 2 + 5 - gameState.stats.vit / 2));
            
            gameState.currentHP -= damage;
            showMessage(`${enemy.name}の反撃！ ${damage}のダメージを受けた！`, 3000);

            if (gameState.currentHP <= 0) {
                gameState.currentHP = 0;
                setTimeout(() => endCombat('LOSE'), 3500);
            } else {
                setTimeout(() => gameState.combatLock = false, 3500);
            }
        }

        function checkLevelUp() {
            const expNeeded = gameState.level * 100 * 1.2;
            if (gameState.exp >= expNeeded) {
                gameState.level++;
                gameState.exp = 0; 
                
                const job = JOB_BASE_STATS[gameState.job] || {str:2, mag:2, vit:2, spd:2};
                gameState.stats.str += Math.ceil(job.str / 3);
                gameState.stats.mag += Math.ceil(job.mag / 3);
                gameState.stats.vit += Math.ceil(job.vit / 3);
                gameState.stats.spd += Math.ceil(job.spd / 3);
                gameState.maxHP += 10 + Math.floor(job.vit / 2);
                gameState.currentHP = gameState.maxHP;
                showMessage(`レベルアップ！ Lv${gameState.level}になり、システム性能が向上しました。`, 5000);
            }
        }
        
        function checkStoryEvent(x, y) {
            if (gameMap[y][x] === TILE_START && !gameState.eventFlags['START_TUTORIAL']) {
                gameState.eventFlags['START_TUTORIAL'] = true;
                showMessage("【システムログ】認証完了。ネットワーク内の脆弱性を特定し、パッチを適用せよ。右下の『ルートディレクトリ』を目指してください。", 8000);
                return true;
            }
            if (x === 8 && y === 8 && !gameState.eventFlags['MID_WARNING']) {
                gameState.eventFlags['MID_WARNING'] = true;
                showMessage("【警告】このセクターはデータ破損が激しい。DoS攻撃の痕跡があります。慎重に進んでください。", 6000);
                return true;
            }
            if (x === 3 && y === 12 && !gameState.eventFlags['SECRET_CACHE']) {
                gameState.eventFlags['SECRET_CACHE'] = true;
                gameState.exp += 50;
                showMessage("【発見】古いキャッシュデータを発見。「password123」...脆弱なパスワードだ。経験値+50", 6000);
                return true;
            }
            if (x === 14 && y === 14) {
                if (!gameState.eventFlags['BOSS_DEFEATED']) {
                    initCombat({
                        name: '魔王エクスプロイト', maxHP: 300, currentHP: 300, level: 20, type: 'ZeiJack', isBoss: true
                    });
                    return true;
                } else {
                    showMessage("ここは浄化されたルートディレクトリだ。平和なパケットが流れている。", 4000);
                    return true;
                }
            }
            return false;
        }

        function showMessage(text, duration = 3000) {
            clearTimeout(messageTimer);
            const box = document.getElementById('message-box');
            const p = document.getElementById('message-text');
            p.textContent = text;
            box.classList.remove('hidden');
            
            if (text.includes("警告") || text.includes("ダメージ") || text.includes("魔王")) {
                p.className = "text-lg leading-relaxed text-red-300";
            } else if (text.includes("発見") || text.includes("レベルアップ") || text.includes("勝利")) {
                p.className = "text-lg leading-relaxed text-yellow-300";
            } else {
                p.className = "text-lg leading-relaxed text-green-300";
            }
            
            messageTimer = setTimeout(() => box.classList.add('hidden'), duration);
        }

        function updateStatusDisplay() {
            document.getElementById('playerJob').textContent = `${gameState.job || '未定義'}`;
            document.getElementById('playerLevel').textContent = `Lv: ${gameState.level}`;
            document.getElementById('playerHP').textContent = `HP: ${gameState.currentHP} / ${gameState.maxHP}`;
            
            if (gameState.mode === 'COMBAT' && gameState.currentEnemy) {
                const enemy = gameState.currentEnemy;
                document.getElementById('enemyName').textContent = `${enemy.name}`;
                document.getElementById('enemyHpText').textContent = `${enemy.currentHP} / ${enemy.maxHP}`;
                document.getElementById('enemyHpBar').style.width = `${(enemy.currentHP / enemy.maxHP) * 100}%`;
            }

            const statsText = `
Lv: ${gameState.level} (${gameState.job})
HP: ${gameState.currentHP}/${gameState.maxHP}
EXP: ${gameState.exp}
STR: ${gameState.stats.str} | MAG: ${gameState.stats.mag}
VIT: ${gameState.stats.vit} | SPD: ${gameState.stats.spd}

[ロール特性]
${JOB_BASE_STATS[gameState.job]?.desc || '未選択'}
            `.trim();
            document.getElementById('statusText').textContent = statsText;
            document.getElementById('jobSelection').classList.toggle('hidden', gameState.isJobSelected);
        }

        function renderCombatMenu() {
            const list = document.getElementById('commandList');
            list.innerHTML = '';
            COMBAT_COMMANDS.forEach((cmd, idx) => {
                const div = document.createElement('div');
                div.className = `menu-item ${idx === gameState.selectedCommand ? 'selected' : 'text-white'}`;
                div.textContent = cmd;
                div.onclick = () => executeCommand(cmd);
                list.appendChild(div);
            });
        }

        // --- メニュー・UI操作 ---
        window.openMenu = function() {
            if (gameState.mode === 'COMBAT') return;
            gameState.isMenuOpen = true;
            document.getElementById('menuModal').classList.remove('hidden');
            updateStatusDisplay();
            isGameLoopRunning = false; // メニュー中はループ停止
        }

        window.closeMenu = function() {
            gameState.isMenuOpen = false;
            document.getElementById('menuModal').classList.add('hidden');
            isGameLoopRunning = true;
            requestAnimationFrame(gameLoop);
        }

        window.selectJob = function(jobName) {
            if (gameState.isJobSelected) return;
            gameState.job = jobName;
            gameState.isJobSelected = true;
            gameState.stats = { ...JOB_BASE_STATS[jobName] };
            gameState.maxHP = 40 + gameState.stats.vit * 2;
            gameState.currentHP = gameState.maxHP;
            showMessage(`ロール: ${jobName} をインストールしました。`, 4000);
            updateStatusDisplay();
        }

        // --- Local Storage セーブ/ロードシステム ---
        const SAVE_KEY_PREFIX = 'zeiJackQuest_save_slot_';
        let currentMenuMode = 'save'; // 'save' or 'load'

        window.openSaveLoadMenu = function(mode) {
            currentMenuMode = mode;
            const modalTitle = document.getElementById('sl-modal-title');
            const slotsContainer = document.getElementById('save-slots');
            
            modalTitle.textContent = mode === 'save' ? 'セーブするスロットを選択' : 'ロードするデータを選択';
            slotsContainer.innerHTML = '';

            for (let i = 1; i <= 3; i++) {
                const key = SAVE_KEY_PREFIX + i;
                const dataJson = localStorage.getItem(key);
                const btn = document.createElement('button');
                btn.className = 'slot-button';
                
                if (dataJson) {
                    const data = JSON.parse(dataJson);
                    const date = new Date(data.timestamp).toLocaleString();
                    btn.innerHTML = `
                        <div>Slot ${i} <span class="slot-date">${date}</span></div>
                        <div class="slot-info">Lv.${data.level} ${data.job || 'No Job'} - HP:${data.currentHP}/${data.maxHP}</div>
                        <div class="slot-info text-xs text-gray-500">Loc: (${data.x}, ${data.y})</div>
                    `;
                    btn.onclick = () => handleSlotAction(i);
                } else {
                    btn.innerHTML = `<div>Slot ${i}</div><div class="slot-button empty">No Data</div>`;
                    if (mode === 'save') {
                        btn.onclick = () => handleSlotAction(i);
                    } else {
                        btn.disabled = true;
                        btn.style.opacity = '0.5';
                        btn.style.cursor = 'default';
                    }
                }
                slotsContainer.appendChild(btn);
            }

            document.getElementById('save-load-modal').classList.remove('hidden');
            // メインメニューを一時的に隠す
            if(mode === 'save') document.getElementById('menuModal').classList.add('hidden');
        };

        window.closeSaveLoadMenu = function() {
            document.getElementById('save-load-modal').classList.add('hidden');
            // セーブモードだった場合はメインメニューに戻る
            if (currentMenuMode === 'save') {
                document.getElementById('menuModal').classList.remove('hidden');
            }
        };

        function handleSlotAction(slotNum) {
            if (currentMenuMode === 'save') {
                saveToSlot(slotNum);
            } else {
                loadFromSlot(slotNum);
            }
            window.closeSaveLoadMenu();
        }

        function saveToSlot(slotNum) {
            const saveState = {
                ...gameState,
                timestamp: Date.now()
            };
            try {
                localStorage.setItem(SAVE_KEY_PREFIX + slotNum, JSON.stringify(saveState));
                showMessage(`スロット${slotNum}にセーブしました。`, 3000);
            } catch (e) {
                console.error(e);
                showMessage("セーブに失敗しました（容量不足など）。", 3000);
            }
        }

        function loadFromSlot(slotNum) {
            const dataJson = localStorage.getItem(SAVE_KEY_PREFIX + slotNum);
            if (dataJson) {
                const data = JSON.parse(dataJson);
                gameState = { ...INITIAL_GAME_STATE, ...data }; // マージしてロード
                
                // 画面遷移
                document.getElementById('title-screen').classList.add('hidden');
                document.getElementById('main-container').classList.remove('hidden');
                
                // 初期化
                isGameLoopRunning = true;
                gameState.isMenuOpen = false;
                document.getElementById('menuModal').classList.add('hidden');
                
                showMessage("データをロードしました。", 3000);
                requestAnimationFrame(gameLoop);
            }
        }

        // --- タイトル画面操作 ---
        window.startNewGame = function() {
            gameState = JSON.parse(JSON.stringify(INITIAL_GAME_STATE)); // リセット
            document.getElementById('title-screen').classList.add('hidden');
            document.getElementById('main-container').classList.remove('hidden');
            
            initGame();
            setTimeout(() => {
                showMessage("【プロローグ】時は2045年。電脳空間は未知のウイルス「ゼイジャック」により汚染されていた。", 6000);
            }, 1000);
        };

        window.returnToTitle = function() {
            isGameLoopRunning = false;
            document.getElementById('main-container').classList.add('hidden');
            document.getElementById('title-screen').classList.remove('hidden');
        };

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('save-load-modal').classList.contains('hidden') === false) {
                if (e.key === 'Escape') window.closeSaveLoadMenu();
                return;
            }
            if (gameState.isMenuOpen) {
                if (e.key === 'e' || e.key === 'E' || e.key === 'Escape') window.closeMenu();
                return;
            }
            
            if (gameState.mode === 'OVERWORLD' && isGameLoopRunning) {
                if (e.key === 'ArrowUp') attemptMove(0, -1);
                if (e.key === 'ArrowDown') attemptMove(0, 1);
                if (e.key === 'ArrowLeft') attemptMove(-1, 0);
                if (e.key === 'ArrowRight') attemptMove(1, 0);
                if (e.key === 'e' || e.key === 'E') window.openMenu();
            } else if (gameState.mode === 'COMBAT' && !gameState.combatLock) {
                if (e.key === 'ArrowUp') gameState.selectedCommand = Math.max(0, gameState.selectedCommand - 1);
                if (e.key === 'ArrowDown') gameState.selectedCommand = Math.min(COMBAT_COMMANDS.length - 1, gameState.selectedCommand + 1);
                if (e.key === 'Enter') executeCommand(COMBAT_COMMANDS[gameState.selectedCommand]);
                renderCombatMenu();
            }
        });
    </script>
</body>
</html>
