<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebaseé‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© - 2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebaseã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, updateDoc, arrayUnion, runTransaction, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestoreã®ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š (ãƒ‡ãƒãƒƒã‚°ç”¨)
        setLogLevel('debug');

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆCanvasç’°å¢ƒã‹ã‚‰æä¾›ã•ã‚Œã‚‹ã‚‚ã®ã‚’å–å¾—ï¼‰
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBPMqx8KHacF0XiRLSRztgXiRHoGdXFpCQ",
            authDomain: "talk-to-friends-point.firebaseapp.com",
            projectId: "talk-to-friends-point",
            storageBucket: "talk-to-friends-point.firebaseapp.com",
            messagingSenderId: "1012267135320",
            appId: "1:1012267135320:web:1bb99aa6249c88bfac752d",
            measurementId: "G-RFX7NK1Q28"
        };
        
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_CONFIG.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Firebaseã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let app;
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        let playerName = null; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å

        // ã‚²ãƒ¼ãƒ é–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let roomId = '';
        let roomRef = null;
        let roomData = null;
        let unsubscribeRoom = null;
        let isHost = false; 
        
        let myPlayerIndex = -1; 
        let playerHand = [];
        // NOTE: playerOpenTilesã¯ã€ãƒ­ãƒ¼ã‚«ãƒ«ã§ã¯Array<Array<string>>ã¨ã—ã¦æ‰±ã†
        let playerOpenTiles = []; // å…¬é–‹ç‰Œ (3æšçµ„ã§å›ºå®šã•ã‚ŒãŸç‰Œ)
        let isDrawingPhase = false; // true: ç‰Œã‚’å¼•ã„ãŸç›´å¾Œ (9æšçŠ¶æ…‹) ã¾ãŸã¯ é³´ã„ãŸç›´å¾Œ (6æšçŠ¶æ…‹)
        let selectedTileId = null;

        // ã‚²ãƒ¼ãƒ å®šæ•° (é‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ä»•æ§˜)
        const TILE_TYPES = [
            'P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9'
        ]; // é‡çƒãƒã‚¸ã‚·ãƒ§ãƒ³ 1ã€œ9 (æŠ•æ‰‹ã€œãƒ©ã‚¤ãƒˆ)
        const TILE_NAMES = {
            'P1': 'æŠ•', 'P2': 'æ•', 'P3': 'ä¸€', 'P4': 'äºŒ', 'P5': 'ä¸‰', 'P6': 'éŠ', 'P7': 'å·¦', 'P8': 'ä¸­', 'P9': 'å³'
        };
        const SPECIAL_TILE = 'OT'; // å¤§è°·ç‰Œ
        const SPECIAL_TILE_NAME = 'å¤§è°·';

        const TILES_PER_TYPE = 5; // é€šå¸¸ç‰Œã¯å„5æš
        const SPECIAL_TILES_COUNT = 3; // å¤§è°·ç‰Œã¯3æš
        const HAND_SIZE_START = 8;
        const HAND_SIZE_WIN = 9;

        // DOMè¦ç´ ã®å–å¾—
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const drawButton = document.getElementById('draw-button');
        const checkButton = document.getElementById('check-button');
        const discardSelectedButton = document.getElementById('discard-selected-button');
        const callOpenSetButton = document.getElementById('call-open-set-button'); // é³´ããƒœã‚¿ãƒ³
        const skipActionButton = document.getElementById('skip-action-button');   // è¦‹é€ã‚Šãƒœã‚¿ãƒ³
        const handContainer = document.getElementById('hand-container');
        const openTilesContainer = document.getElementById('open-tiles-container'); 
        const opponentHandContainer = document.getElementById('opponent-hand-container');
        const opponentOpenTilesContainer = document.getElementById('opponent-open-tiles-container'); 
        const deckCountDisplay = document.getElementById('deck-count');
        const discardContainer = document.getElementById('discard-container');
        const messageBox = document.getElementById('message-box');
        const connectionStatus = document.getElementById('connection-status');
        const currentTurnDisplay = document.getElementById('current-turn');
        const userIdDisplay = document.getElementById('user-id-display');
        const playerNameDisplay = document.getElementById('player-name-display');
        
        // ãƒãƒ£ãƒƒãƒˆé–¢é€£DOMè¦ç´ 
        const messagesList = document.getElementById('messages-list');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');

        // -----------------------------------------------------
        // 1. FirebaseåˆæœŸåŒ–ã¨èªè¨¼
        // -----------------------------------------------------

        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    userIdDisplay.textContent = `å†…éƒ¨ID: ${userId}`;
                    displayMessage("èªè¨¼å®Œäº†ã€‚åå‰ã‚’è¨­å®šã—ã€ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã¾ãŸã¯å‚åŠ ã—ã¦ãã ã•ã„ã€‚", 'normal');
                    document.getElementById('loading-message').style.display = 'none';
                    lobbyContainer.style.display = 'block';
                    connectionStatus.textContent = 'åŒæœŸå¾…æ©Ÿä¸­...';
                    connectionStatus.style.backgroundColor = '#ccc';
                    updateLobbyButtonState();
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                }

            } catch (error) {
                console.error("FirebaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("FirebaseåˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }
        
        function setPlayerName() {
             const nameInput = document.getElementById('player-name-input');
             const name = nameInput.value.trim();
             if (name) {
                 playerName = name;
                 playerNameDisplay.textContent = `ã‚ãªãŸã®åå‰: ${playerName}`;
                 document.getElementById('set-name-message').textContent = 'åå‰ãŒè¨­å®šã•ã‚Œã¾ã—ãŸã€‚';
                 nameInput.disabled = true;
                 document.getElementById('set-name-button').disabled = true;
                 updateLobbyButtonState();
             } else {
                 document.getElementById('set-name-message').textContent = 'ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚';
             }
        }
        
        function updateLobbyButtonState() {
             const isDisabled = !isAuthReady || !playerName;
             document.getElementById('create-room-button').disabled = isDisabled;
             document.getElementById('join-room-button').disabled = isDisabled;
        }

        // -----------------------------------------------------
        // 2. ãƒ«ãƒ¼ãƒ ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function getRoomCollectionRef() {
            // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³: /artifacts/{appId}/public/data/donjara_rooms
            return collection(db, 'artifacts', appId, 'public', 'data', 'donjara_rooms');
        }

        /**
         * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ–
         */
        function createInitialRoomData() {
            let initialDeck = [];
            
            for (const type of TILE_TYPES) {
                for (let i = 1; i <= TILES_PER_TYPE; i++) {
                    initialDeck.push(`${type}-${i}`);
                }
            }
            for (let i = 1; i <= SPECIAL_TILES_COUNT; i++) {
                 initialDeck.push(`${SPECIAL_TILE}-${i}`);
            }
            shuffle(initialDeck);

            return {
                players: [],
                deck: initialDeck,
                discardedTiles: [],
                currentPlayerId: '',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                messages: [],
                // é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–¢é€£
                lastDiscardedTile: null,
                discarderId: null,      
                isDiscardActionPending: false, // true: ç›¸æ‰‹ãŒé³´ã/è¦‹é€ã‚Šã‚’å¾…ã£ã¦ã„ã‚‹çŠ¶æ…‹
                lastUpdated: Date.now()
            };
        }

        async function createRoom() {
            if (!isAuthReady || !userId || !playerName) return;

            roomId = crypto.randomUUID().substring(0, 8);
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = true;

            try {
                const roomSnapshot = await getDoc(roomRef);
                if (roomSnapshot.exists()) {
                     displayMessage("ãƒ«ãƒ¼ãƒ IDãŒé‡è¤‡ã—ã¾ã—ãŸã€‚å†è©¦è¡Œã—ã¾ã™ã€‚", 'error');
                     return;
                }

                await setDoc(roomRef, createInitialRoomData());
                await joinRoom(roomId);
            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        async function joinRoom(id) {
            if (!isAuthReady || !userId || !playerName) return;
            roomId = id || document.getElementById('room-id-input').value.trim();
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = false; 

            if (!roomId) {
                displayMessage("ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", 'error');
                return;
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnapshot = await transaction.get(roomRef);
                    if (!roomSnapshot.exists()) {
                        throw new Error(`ãƒ«ãƒ¼ãƒ ID: ${roomId} ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`);
                    }

                    const currentRoomData = roomSnapshot.data();
                    
                    if (currentRoomData.status !== 'waiting' || currentRoomData.players.length >= 2) {
                        throw new Error("ã“ã®ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã‹ã€æ—¢ã«ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                    }
                    
                    const existingPlayer = currentRoomData.players.find(p => p.userId === userId);
                    if (existingPlayer) {
                         myPlayerIndex = currentRoomData.players.indexOf(existingPlayer);
                         // NOTE: openTilesãŒJSON stringã§ä¿å­˜ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã§ã¯æ‰±ã‚ãªã„
                         playerName = existingPlayer.displayName; // æ—¢å­˜ã®åå‰ã‚’ä½¿ç”¨
                         return;
                    }

                    const isNewHost = currentRoomData.players.length === 0;
                    // openTilesã¯é…åˆ—ã®é…åˆ—ã«ãªã‚‹ãŸã‚ã€Firestoreã®åˆ¶ç´„ã‚’é¿ã‘ã‚‹ãŸã‚ã«JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
                    const newPlayer = { 
                        userId, 
                        displayName: playerName, 
                        hand: [], 
                        openTiles: JSON.stringify([]), // <<-- JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                        isHost: isNewHost 
                    };
                    const newPlayers = [...currentRoomData.players, newPlayer];
                    myPlayerIndex = newPlayers.length - 1; 

                    transaction.update(roomRef, {
                        players: newPlayers,
                        lastUpdated: Date.now()
                    });
                    
                    isHost = isNewHost;
                });

                document.getElementById('room-title').textContent = `ãƒ«ãƒ¼ãƒ ID: ${roomId}`;
                lobbyContainer.style.display = 'none';
                gameContainer.style.display = 'flex';
                document.getElementById('game-content').style.display = 'block';

                startRoomListener();
                connectionStatus.textContent = 'åŒæœŸä¸­ (Firebase)';
                connectionStatus.style.backgroundColor = '#4CAF50'; 

            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ãƒ«ãƒ¼ãƒ å‚åŠ å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        /**
         * ãƒ«ãƒ¼ãƒ ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦– (FirebaseåŒæœŸã®ã‚³ã‚¢)
         */
        function startRoomListener() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            unsubscribeRoom = onSnapshot(roomRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const oldData = roomData;
                    roomData = docSnapshot.data();
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ
                    const myState = roomData.players.find(p => p.userId === userId);
                    if (myState) {
                        myPlayerIndex = roomData.players.indexOf(myState);
                        playerHand = myState.hand || [];
                        
                        // å…¬é–‹ç‰Œã‚’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«å¤‰æ•°ã«æ ¼ç´
                        try {
                            playerOpenTiles = JSON.parse(myState.openTiles || '[]');
                        } catch (e) {
                            console.error("Error parsing playerOpenTiles:", e);
                            playerOpenTiles = [];
                        }
                        
                        isHost = myState.isHost;
                        playerName = myState.displayName; // åå‰ã‚’åŒæœŸ
                    }
                    
                    // ã‚¿ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã®isDrawingPhaseæ›´æ–°
                    if (roomData.currentPlayerId === userId && !roomData.isDiscardActionPending) {
                        // isDrawingPhaseã¯ã€Œç‰Œã‚’æ¨ã¦ãªã‘ã‚Œã°ãªã‚‰ãªã„çŠ¶æ…‹ã€ã‚’ç¤ºã™
                        if (playerHand.length === HAND_SIZE_WIN || playerHand.length === HAND_SIZE_START - 2) {
                             // 9æš (å¼•ã„ãŸç›´å¾Œ) ã¾ãŸã¯ 6æš (é³´ã„ãŸç›´å¾Œ - ãƒãƒ³) ã®å ´åˆ
                             isDrawingPhase = true;
                             displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã€ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", 'success');
                             selectedTileId = null; 
                        } else {
                             // 8æš (é€šå¸¸çŠ¶æ…‹) ã¾ãŸã¯ 5æš (ãƒãƒ³å¾Œã®æ¨ã¦ç‰Œã‚’çµ‚ãˆãŸçŠ¶æ…‹) ã®å ´åˆ
                             isDrawingPhase = false;
                             displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã„ã¦ãã ã•ã„ã€‚", 'success');
                             selectedTileId = null; 
                        }
                    } else if (roomData.isDiscardActionPending && roomData.discarderId !== userId) {
                         // ç›¸æ‰‹ã®æ¨ã¦ç‰Œã«å¯¾ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©ŸçŠ¶æ…‹
                         isDrawingPhase = false;
                         const discardedTile = roomData.lastDiscardedTile.startsWith(SPECIAL_TILE) ? SPECIAL_TILE_NAME : TILE_NAMES[roomData.lastDiscardedTile.substring(0, 2)];
                         displayMessage(`ç›¸æ‰‹ãŒã€Œ${discardedTile}ã€ã‚’æ¨ã¦ã¾ã—ãŸã€‚é³´ãã‹è¦‹é€ã‚‹ã‹é¸æŠã—ã¦ãã ã•ã„ã€‚`, 'normal');
                    } else if (roomData.currentPlayerId !== userId && !roomData.isDiscardActionPending) {
                         // ç›¸æ‰‹ãŒå±±æœ­ã‹ã‚‰å¼•ãã®ã‚’å¾…ã£ã¦ã„ã‚‹çŠ¶æ…‹
                         isDrawingPhase = false;
                         displayMessage("ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚ãŠå¾…ã¡ãã ã•ã„ã€‚", 'normal');
                    }

                    if (roomData.status === 'finished') {
                        endGame(roomData.winnerId || null);
                        return;
                    }

                    // UIã®æ›´æ–°
                    updateUI(); 
                    updateGameUI(roomData);
                    
                    if (roomData.messages) {
                        renderMessages(roomData.messages);
                    }

                } else {
                    displayMessage("ãƒ«ãƒ¼ãƒ ã¯å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚", 'error');
                    if (unsubscribeRoom) {
                        unsubscribeRoom();
                        unsubscribeRoom = null;
                    }
                    location.reload(); 
                }
            });
        }
        
        async function startGame() {
            if (!isHost || roomData.status !== 'waiting' || roomData.players.length !== 2) return;

            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.players.length !== 2) return;

                    // playersé…åˆ—ã‚’åˆæœŸåŒ–ã—ã€openTilesã‚’JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜
                    const players = currentRoomData.players.map(p => ({ 
                        ...p, 
                        hand: [], 
                        openTiles: JSON.stringify([]) // <<-- JSONã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                    }));
                    
                    let deck = currentRoomData.deck;

                    for (let i = 0; i < HAND_SIZE_START; i++) {
                        players.forEach(p => {
                            const tile = deck.pop();
                            if(tile) p.hand.push(tile); 
                        });
                    }

                    const startingPlayerId = players[Math.floor(Math.random() * 2)].userId;

                    transaction.update(roomRef, {
                        players: players,
                        deck: deck,
                        currentPlayerId: startingPlayerId,
                        status: 'playing',
                        lastDiscardedTile: null,
                        discarderId: null,
                        isDiscardActionPending: false, 
                        lastUpdated: Date.now()
                    });
                });
            } catch (error) {
                console.error("ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ã‚²ãƒ¼ãƒ é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }
        
        // -----------------------------------------------------
        // 3. UI/è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------
        
        function displayMessage(text, type = 'normal') {
            messageBox.textContent = text;
            messageBox.className = '';
            messageBox.classList.add('message-box');
            if (type === 'success') {
                messageBox.classList.add('message-success');
            } else if (type === 'error') {
                messageBox.classList.add('message-error');
            } else {
                 messageBox.classList.add('message-normal');
            }
        }

        function updateGameUI(data) {
            if (!data || data.status !== 'playing') {
                // ãƒ­ãƒ“ãƒ¼è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯
                currentTurnDisplay.textContent = 'ã‚²ãƒ¼ãƒ å¾…ã¡';
                currentTurnDisplay.style.backgroundColor = '#ccc';
                drawButton.disabled = true;
                checkButton.disabled = true;
                discardSelectedButton.style.display = 'none';
                callOpenSetButton.style.display = 'none';
                skipActionButton.style.display = 'none';
                document.getElementById('start-game-button').style.display = (isHost && data && data.players.length === 2 && data.status === 'waiting') ? 'inline-block' : 'none';
                
                const playersInfo = data ? data.players.map(p => 
                    `${p.displayName || `User-${p.userId.substring(0, 4)}`} ${p.userId === userId ? '(ã‚ãªãŸ)' : '(ç›¸æ‰‹)'} ${p.isHost ? '(HOST)' : ''}`
                ).join(' / ') : 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: 1äºº';
                document.getElementById('player-list').textContent = playersInfo;
                
                return;
            }
            
            const myTurn = data.currentPlayerId === userId;
            const isActionPending = data.isDiscardActionPending === true;
            const isMyTurnToAct = isActionPending && data.discarderId !== userId;
            const opponentPlayerState = data.players.find(p => p.userId !== userId);
            
            // ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
            if (isActionPending && data.discarderId !== userId) {
                 currentTurnDisplay.textContent = 'ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é¸æŠ';
                 currentTurnDisplay.style.backgroundColor = '#ffcc99'; 
            } else {
                 currentTurnDisplay.textContent = myTurn ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
                 currentTurnDisplay.style.backgroundColor = myTurn ? '#aaffaa' : '#ffaaaa';
            }
            
            // ãƒœã‚¿ãƒ³åˆ¶å¾¡
            // å±±æœ­ã‹ã‚‰å¼•ããƒœã‚¿ãƒ³
            // æ¨ã¦ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã§ãªã„ (æ‰‹ç‰ŒãŒ8æšã¾ãŸã¯5æš) ã‹ã¤ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿä¸­ã§ãªã„æ™‚ã®ã¿å¼•ã‘ã‚‹
            drawButton.disabled = !myTurn || isDrawingPhase || data.deck.length === 0 || isActionPending;
            
            // å½¹åˆ¤å®šãƒœã‚¿ãƒ³
            // æ¨ã¦ã‚‹ãƒ•ã‚§ãƒ¼ã‚º (isDrawingPhase=true) ã‹ã¤ 9æšã®æ™‚ã®ã¿ãƒã‚§ãƒƒã‚¯å¯èƒ½ (ãƒãƒ³ç›´å¾Œ6æšã§ã¯ä¸å¯)
            checkButton.disabled = !myTurn || playerHand.length !== HAND_SIZE_WIN || isActionPending;
            
            // æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³
            // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã§ã€æ¨ã¦ã‚‹ãƒ•ã‚§ãƒ¼ã‚º(isDrawingPhase=true)ã‹ã¤ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿä¸­ã§ãªã„å ´åˆã«è¡¨ç¤º
            discardSelectedButton.style.display = (myTurn && isDrawingPhase && !isActionPending) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTileId;
            
            // é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã®åˆ¶å¾¡ (ç›¸æ‰‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å ´åˆã®ã¿)
            callOpenSetButton.style.display = isMyTurnToAct ? 'inline-block' : 'none';
            skipActionButton.style.display = isMyTurnToAct ? 'inline-block' : 'none';
            callOpenSetButton.disabled = false; 
            skipActionButton.disabled = false;
            
            // å±±æœ­ã¨æ¨ã¦ç‰Œ
            deckCountDisplay.textContent = data.deck.length;
            renderDiscardedTiles(data.discardedTiles);

            // ç›¸æ‰‹ã®æ‰‹ç‰Œã¨å…¬é–‹ç‰Œ
            opponentHandContainer.innerHTML = '';
            opponentOpenTilesContainer.innerHTML = '';
            if (opponentPlayerState) {
                const opponentHandSize = opponentPlayerState.hand.length;
                for (let i = 0; i < opponentHandSize; i++) {
                    opponentHandContainer.appendChild(Object.assign(document.createElement('div'), { className: 'tile face-down' }));
                }
                
                // ç›¸æ‰‹ã®å…¬é–‹ç‰Œã‚’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
                let opponentOpenSets = [];
                try {
                    opponentOpenSets = JSON.parse(opponentPlayerState.openTiles || '[]'); // <<-- ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                } catch (e) {
                    console.error("Failed to parse opponent open tiles:", e);
                }
                renderOpenTiles(opponentOpenSets, opponentOpenTilesContainer, true);
            }
        }
        
        /**
         * æ‰‹ç‰ŒUIã‚’æ›´æ–°
         */
        function updateUI() {
            // æ‰‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            handContainer.innerHTML = '';
            playerHand.sort((a, b) => {
                const typeA = a.substring(0, 2);
                const typeB = b.substring(0, 2);
                if (typeA === SPECIAL_TILE && typeB !== SPECIAL_TILE) return 1;
                if (typeA !== SPECIAL_TILE && typeB === SPECIAL_TILE) return -1;
                return a.localeCompare(b);
            });

            playerHand.forEach(tileId => {
                const tileEl = createTileElement(tileId);
                if (tileId === selectedTileId) {
                     tileEl.classList.add('selected');
                }
                handContainer.appendChild(tileEl);
            });
            
            // å…¬é–‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            // playerOpenTilesã¯onSnapshotã§æ—¢ã«ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚Œã¦ã„ã‚‹
            renderOpenTiles(playerOpenTiles, openTilesContainer);

            // é¸æŠçŠ¶æ…‹ã®æ›´æ–°ã«å¿œã˜ã¦æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã‚’åˆ¶å¾¡
            const selectedTile = handContainer.querySelector('.tile.selected');
            const myTurn = roomData && roomData.currentPlayerId === userId;
            
            discardSelectedButton.style.display = (myTurn && isDrawingPhase && !roomData.isDiscardActionPending) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTile;
            
            document.getElementById('hand-count').textContent = playerHand.length;
        }

        /**
         * å…¬é–‹ç‰Œã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
         */
        function renderOpenTiles(openSets, container, isOpponent = false) {
            container.innerHTML = '';
            openSets.forEach(set => {
                const setContainer = document.createElement('div');
                setContainer.className = 'open-tile-set';
                // 3æšã®ç‰Œã‚’ã‚»ãƒƒãƒˆã¨ã—ã¦è¡¨ç¤º
                set.forEach(tileId => {
                    setContainer.appendChild(createTileElement(tileId, false));
                });
                container.appendChild(setContainer);
            });
        }

        /**
         * ç‰ŒDOMè¦ç´ ã®ç”Ÿæˆ
         */
        function createTileElement(tileId, selectable = true) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.setAttribute('data-id', tileId);
            const type = tileId.substring(0, 2);
            tile.setAttribute('data-type', type);
            
            if (type === SPECIAL_TILE) {
                tile.textContent = SPECIAL_TILE_NAME;
                tile.classList.add('special-tile');
                tile.title = "å¤§è°·ç‰Œ (ã‚ªãƒ¼ãƒ«ãƒã‚¤ãƒ†ã‚£)"; 
            } else {
                tile.textContent = TILE_NAMES[type] || type; 
            }

            if (selectable) {
                tile.addEventListener('click', handleTileClick);
            }
            return tile;
        }
        
        function renderDiscardedTiles(tiles) {
            discardContainer.innerHTML = '';
            // æœ€æ–°ã®15æšã‚’è¡¨ç¤º
            tiles.slice(-15).forEach(tileId => {
                 discardContainer.appendChild(createTileElement(tileId, false));
            });
        }

        function handleTileClick(event) {
            // ç‰Œã‚’å¼•ã„ãŸç›´å¾Œ (isDrawingPhase=true) ã§ã®ã¿æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠå¯èƒ½
            // isDrawingPhaseãŒtrueãªã‚‰ã€æ‰‹ç‰ŒãŒ9æšï¼ˆå¼•ã„ãŸå¾Œï¼‰ã‹6æšï¼ˆé³´ã„ãŸå¾Œï¼‰ã®çŠ¶æ…‹ã§ã™ã€‚
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase || roomData.isDiscardActionPending) {
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæŒ‡æ‘˜ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã€ã‚ˆã‚Šç°¡æ½”ã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¿ƒã™å½¢ã«å¤‰æ›´
                displayMessage("ç¾åœ¨ã€ç‰Œã‚’**é¸æŠã—ã¦æ¨ã¦ã‚‹ãƒ•ã‚§ãƒ¼ã‚º**ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", 'error');
                return;
            }

            const tileElement = event.currentTarget;
            const tileId = tileElement.getAttribute('data-id');

            const isSelected = tileElement.classList.contains('selected');
            
            // å…¨ã¦ãƒªã‚»ãƒƒãƒˆ
            handContainer.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            selectedTileId = null;

            if (!isSelected) {
                // æ–°ã—ãé¸æŠ
                tileElement.classList.add('selected');
                selectedTileId = tileId;
                const tileDisplayName = (tileId.startsWith(SPECIAL_TILE)) ? SPECIAL_TILE_NAME : TILE_NAMES[tileId.substring(0, 2)];
                displayMessage(`${tileDisplayName}ã®ç‰Œã‚’é¸æŠã—ã¾ã—ãŸã€‚ã“ã®ç‰Œã‚’æ¨ã¦ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚`);
            } else {
                displayMessage("æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
            }
            updateGameUI(roomData);
        }
        
        // -----------------------------------------------------
        // 4. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ (Firestoreã¸ã®æ›¸ãè¾¼ã¿)
        // -----------------------------------------------------

        /**
         * å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã
         */
        async function drawTile() {
            // isDrawingPhase=true ã¯æ¨ã¦ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã‚’æ„å‘³ã™ã‚‹ãŸã‚ã€ã“ã“ã§ã¯å¼•ã‘ãªã„
            if (!roomData || roomData.currentPlayerId !== userId || isDrawingPhase || roomData.deck.length === 0 || roomData.isDiscardActionPending) return;
            
            // ç‰Œã‚’å¼•ãã“ã¨ãŒã§ãã‚‹ã®ã¯ã€æ‰‹ç‰ŒãŒ8æšã¾ãŸã¯5æšã®æ™‚
            if (playerHand.length !== HAND_SIZE_START && playerHand.length !== (HAND_SIZE_START - 3)) {
                 displayMessage("ç‰Œã‚’å¼•ãã«ã¯ã€æ‰‹ç‰ŒãŒ8æšï¼ˆé€šå¸¸ï¼‰ã¾ãŸã¯5æšï¼ˆãƒãƒ³å¾Œï¼‰ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚", 'error');
                 return;
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId || currentRoomData.deck.length === 0) {
                        throw new Error("ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€ã¾ãŸã¯å±±æœ­ãŒç©ºã§ã™ã€‚");
                    }

                    const drawnTile = currentRoomData.deck.pop();
                    currentRoomData.players[myPlayerIndex].hand.push(drawnTile);

                    transaction.update(roomRef, {
                        deck: currentRoomData.deck,
                        players: currentRoomData.players,
                        lastUpdated: Date.now()
                    });
                });

                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã®ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–°
                // NOTE: onSnapshotã§isDrawingPhaseãŒæ­£ç¢ºã«æ›´æ–°ã•ã‚Œã‚‹ãŒã€å³æ™‚æ€§ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã«ã“ã“ã§ã‚‚æ›´æ–°
                isDrawingPhase = true;
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                displayMessage("å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ãã¾ã—ãŸ (æ‰‹ç‰Œ9æš)ã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã€ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", 'success');

            } catch (error) {
                console.error("ç‰Œã‚’å¼•ãã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ç‰Œã‚’å¼•ãã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        /**
         * é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹ (é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿãƒ•ã‚§ãƒ¼ã‚ºã¸ç§»è¡Œ)
         */
        async function discardSelectedTile() {
            // isDrawingPhase=true ã§ã‚ã‚Œã°æ‰‹ç‰Œæšæ•°ã«é–¢ã‚ã‚‰ãšæ¨ã¦ã‚‹ã“ã¨ã‚’è¨±å¯ (6æšã¾ãŸã¯9æš)
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase || !selectedTileId || roomData.isDiscardActionPending) return;

            const tileIdToDiscard = selectedTileId;
            const tileType = tileIdToDiscard.substring(0, 2);

            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    const currentHand = currentRoomData.players[myPlayerIndex].hand;
                    const tileIndex = currentHand.indexOf(tileIdToDiscard);
                    
                    if (tileIndex === -1) {
                         throw new Error("æ¨ã¦ã‚‹ç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    }
                    
                    // æ¨ã¦ã‚‹
                    currentHand.splice(tileIndex, 1);
                    currentRoomData.discardedTiles.push(tileIdToDiscard);

                    // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’æ±ºå®š
                    const currentPlayerIndex = currentRoomData.players.findIndex(p => p.userId === userId);
                    const nextPlayerIndex = (currentPlayerIndex + 1) % currentRoomData.players.length;
                    const nextPlayerId = currentRoomData.players[nextPlayerIndex].userId;

                    // é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿãƒ•ã‚§ãƒ¼ã‚ºã¸ç§»è¡Œ
                    const updateData = {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        lastDiscardedTile: tileIdToDiscard, // æ¨ã¦ç‰Œã‚’è¨˜éŒ²
                        discarderId: userId, // æ¨ã¦ãŸäººã‚’è¨˜éŒ²
                        isDiscardActionPending: true, // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                        currentPlayerId: nextPlayerId, // æ¨ã¦ãŸã®ã§ã€ã‚¿ãƒ¼ãƒ³ã¯ä¸€å¿œæ¬¡ã®äººã¸
                        lastUpdated: Date.now()
                    };

                    transaction.update(roomRef, updateData);
                });

                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã®ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–°
                isDrawingPhase = false; 
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                const tileDisplayName = (tileType === SPECIAL_TILE) ? SPECIAL_TILE_NAME : TILE_NAMES[tileType];
                displayMessage(`${tileDisplayName}ã‚’æ¨ã¦ã¾ã—ãŸã€‚ç›¸æ‰‹ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿä¸­ã§ã™ã€‚`);

            } catch (error) {
                 console.error("ç‰Œã‚’æ¨ã¦ã‚‹ã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`ç‰Œã‚’æ¨ã¦ã‚‹ã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }
        
        /**
         * ç›¸æ‰‹ã®æ¨ã¦ç‰Œã«å¯¾ã™ã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã€Œ3æšçµ„ã‚’å…¬é–‹ã™ã‚‹ (ãƒãƒ³)ã€
         */
        async function callOpenSet() {
            if (!roomData || roomData.discarderId === userId || !roomData.isDiscardActionPending) return;

            const discardedTileId = roomData.lastDiscardedTile;
            if (!discardedTileId) return;

            const discardTileType = discardedTileId.substring(0, 2);
            const myCurrentHand = [...playerHand];
            
            // åˆ»å­ (ãƒãƒ³) ã®ãƒã‚§ãƒƒã‚¯: æ¨ã¦ç‰Œã¨æ‰‹ç‰Œã®2æšï¼ˆå¤§è°·ç‰Œå«ã‚€ï¼‰ã§3æšçµ„ã‚’ä½œã‚Œã‚‹ã‹
            let requiredTiles = [];
            let isSetFound = false;
            
            const count = myCurrentHand.filter(tileId => tileId.substring(0, 2) === discardTileType).length;
            const otaniCountInHand = myCurrentHand.filter(tileId => tileId.substring(0, 2) === SPECIAL_TILE).length;
            
            // 1. é€šå¸¸ç‰Œ2æš + æ¨ã¦ç‰Œ1æš (å¤§è°·ç‰Œãªã—)
            if (count >= 2) {
                requiredTiles = myCurrentHand.filter(tileId => tileId.substring(0, 2) === discardTileType).slice(0, 2);
                isSetFound = true;
            } 
            // 2. é€šå¸¸ç‰Œ1æš + å¤§è°·ç‰Œ1æš + æ¨ã¦ç‰Œ1æš
            else if (count >= 1 && otaniCountInHand >= 1) {
                const regular = myCurrentHand.find(tileId => tileId.substring(0, 2) === discardTileType);
                const otani = myCurrentHand.find(tileId => tileId.substring(0, 2) === SPECIAL_TILE);
                requiredTiles = [regular, otani];
                isSetFound = true;
            } 
            // 3. å¤§è°·ç‰Œ2æš + æ¨ã¦ç‰Œ1æš
            else if (otaniCountInHand >= 2) {
                requiredTiles = myCurrentHand.filter(tileId => tileId.substring(0, 2) === SPECIAL_TILE).slice(0, 2);
                isSetFound = true;
            }
            
            if (!isSetFound) {
                const tileDisplayName = (discardTileType === SPECIAL_TILE) ? SPECIAL_TILE_NAME : TILE_NAMES[discardTileType];
                displayMessage(`ã€Œ${tileDisplayName}ã€ã®ç‰Œã§3æšçµ„ã‚’ä½œã‚‹ãƒãƒ³ã¯ã§ãã¾ã›ã‚“ã€‚`, 'error');
                return;
            }
            
            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒç¢ºèªã§ããŸã‚‰ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œ
            try {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    
                    // é³´ã„ãŸäººã®æ‰‹ç‰Œã¨å…¬é–‹ç‰Œã‚’æ›´æ–°
                    const actionPlayer = currentRoomData.players.find(p => p.userId === userId);
                    const actionPlayerIndex = currentRoomData.players.indexOf(actionPlayer);
                    let actionHand = actionPlayer.hand;

                    // å…¬é–‹ç‰Œã‚’ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                    let actionOpenTiles = [];
                    try {
                        actionOpenTiles = JSON.parse(actionPlayer.openTiles || '[]');
                    } catch(e) {
                        console.error("Failed to parse open tiles in transaction:", e);
                    }
                    
                    // 1. æ¨ã¦ç‰Œãƒªã‚¹ãƒˆã‹ã‚‰ç‰Œã‚’å‰Šé™¤ (æœ€å¾Œã®ç‰Œã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª)
                    const lastDiscarded = currentRoomData.discardedTiles.pop();
                    if (lastDiscarded !== discardedTileId) {
                         // ã‚¨ãƒ©ãƒ¼å‡¦ç†ã‚’å³å¯†ã«ã™ã‚‹ãŸã‚ã€ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¸­æ–­ã™ã‚‹
                         throw new Error("ç›´å‰ã®æ¨ã¦ç‰ŒãŒä¸€è‡´ã—ã¾ã›ã‚“ã€‚ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼.");
                    }

                    // 2. é³´ã„ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ç‰Œã‹ã‚‰å¿…è¦ãª2æšã‚’å‰Šé™¤
                    requiredTiles.forEach(tileToRemove => {
                        const index = actionHand.indexOf(tileToRemove);
                        if (index !== -1) {
                            actionHand.splice(index, 1);
                        }
                    });

                    // 3. é³´ã„ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¬é–‹ç‰Œã«è¿½åŠ  (é³´ã„ãŸç‰Œã‚‚å«ã‚€3æšçµ„)
                    actionOpenTiles.push([...requiredTiles, discardedTileId]);
                    
                    // 4. Room Dataã®æ›´æ–° (openTilesã‚’JSONæ–‡å­—åˆ—ã¨ã—ã¦ä¿å­˜)
                    currentRoomData.players[actionPlayerIndex] = {
                        ...actionPlayer,
                        hand: actionHand,
                        openTiles: JSON.stringify(actionOpenTiles) // <<-- å†ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º
                    };
                    
                    // é³´ã„ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¿ãƒ¼ãƒ³ã‚’æ¸¡ã—ã€ã™ãã«æ¨ã¦ã‚‹çŠ¶æ…‹ã«ã™ã‚‹
                    transaction.update(roomRef, {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        lastDiscardedTile: null,
                        discarderId: null,
                        isDiscardActionPending: false, // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çµ‚äº†
                        currentPlayerId: userId, // é³´ã„ãŸäººãŒã™ãã«æ¨ã¦ã‚‹
                        lastUpdated: Date.now()
                    });
                });
                
                displayMessage("3æšçµ„ã‚’å…¬é–‹ã—ã¾ã—ãŸï¼ã“ã®å¾Œã€ä¸è¦ãªç‰Œã‚’1æšæ¨ã¦ã¦ã‚¿ãƒ¼ãƒ³ã‚’çµ‚äº†ã—ã¦ãã ã•ã„ã€‚", 'success');
                isDrawingPhase = true; // é³´ãå¾Œã¯ç‰Œã‚’æ¨ã¦ã‚‹å¿…è¦ãŒã‚ã‚‹ (ãƒ­ãƒ¼ã‚«ãƒ«ã§å³åº§ã«åæ˜ )
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);

            } catch (error) {
                 console.error("é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`é³´ãã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }
        
        /**
         * ç›¸æ‰‹ã®æ¨ã¦ç‰Œã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã€Œè¦‹é€ã‚‹ã€
         */
        async function skipAction() {
            if (!roomData || roomData.discarderId === userId || !roomData.isDiscardActionPending) return;
            
            try {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();

                    // æ¨ã¦ãŸäººã‹ã‚‰è¦‹ã¦æ¬¡ã®äººã®IDã‚’æ±ºå®š
                    const discarderIndex = currentRoomData.players.findIndex(p => p.userId === roomData.discarderId);
                    const nextPlayerIndex = (discarderIndex + 1) % currentRoomData.players.length;
                    const nextPlayerId = currentRoomData.players[nextPlayerIndex].userId;

                    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾…æ©Ÿãƒ•ãƒ©ã‚°ã‚’è§£é™¤ã—ã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¿ãƒ¼ãƒ³ã‚’æ¸¡ã™
                    transaction.update(roomRef, {
                        lastDiscardedTile: null, // æ¨ã¦ç‰Œã¯æµã‚ŒãŸã¨è¦‹ãªã™
                        discarderId: null,
                        isDiscardActionPending: false,
                        currentPlayerId: nextPlayerId, // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¿ãƒ¼ãƒ³ã‚’æ¸¡ã™
                        lastUpdated: Date.now()
                    });
                });
                
                displayMessage("ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¦‹é€ã‚Šã¾ã—ãŸã€‚ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã«åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã™ã€‚", 'normal');
                isDrawingPhase = false;
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);

            } catch (error) {
                console.error("è¦‹é€ã‚Šã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`è¦‹é€ã‚Šã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        /**
         * å½¹ã®åˆ¤å®šã‚’å®Ÿè¡Œ
         */
        async function checkHandForYaku() {
            if (!roomData || roomData.currentPlayerId !== userId || playerHand.length !== HAND_SIZE_WIN || roomData.isDiscardActionPending) return;

            // playerOpenTilesã¯æ—¢ã«ãƒ‡ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã•ã‚Œã¦ã„ã‚‹
            const allTiles = [...playerHand, ...playerOpenTiles.flat()];
            const isYaku = checkYaku(allTiles);

            if (isYaku) {
                displayMessage("ğŸ‰ å½¹ãŒæˆç«‹ã—ã¾ã—ãŸï¼ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰", 'success');
                await updateDoc(roomRef, { 
                    status: 'finished', 
                    winnerId: userId 
                });
            } else {
                displayMessage("å½¹ã¯æˆç«‹ã—ã¦ã„ã¾ã›ã‚“ã€‚åˆ¥ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", 'error');
            }
        }
        
        /**
         * å½¹ã®åˆ¤å®š (3æšçµ„Ã—3 ã¨ é›€é ­(2æšçµ„)Ã—1 ã®æ§‹æˆå¯èƒ½ã‹)
         */
        function checkYaku(allTiles) {
            // è‡ªåˆ†ã®æ‰‹ç‰Œã¨å…¬é–‹ç‰Œã‚’åˆã‚ã›ã¦å½¹ã‚’åˆ¤å®šã™ã‚‹
            
            // å…¬é–‹ç‰ŒãŒãªã„å ´åˆï¼ˆè‡ªåŠ›ãƒ„ãƒ¢ä¸ŠãŒã‚Šåˆ¤å®šï¼‰
            if (playerOpenTiles.length === 0) {
                 if (playerHand.length !== HAND_SIZE_WIN) return false;
                 // 9æšã®æ‰‹ç‰Œã‹ã‚‰1æšã‚’é›€é ­ã¨ã—ã¦ã€æ®‹ã‚Šã®8æšã‚’3æšçµ„Ã—2ã¨é›€é ­Ã—1ã«åˆ†è§£
                 for (let i = 0; i < playerHand.length; i++) {
                     const eightTiles = [...playerHand.slice(0, i), ...playerHand.slice(i + 1)];
                     // é›€é ­ã‚’å«ã‚ã¦8æšã§å½¹ãŒæˆç«‹ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ (å…¬é–‹ç‰Œã¯0ã‚»ãƒƒãƒˆ)
                     if (canFormYaku(eightTiles, 0)) { 
                         return true;
                     }
                 }
                 return false;
            } else {
                // å…¬é–‹ç‰ŒãŒã‚ã‚‹å ´åˆ (é³´ãã‚’å«ã‚€ä¸ŠãŒã‚Šåˆ¤å®š)
                 if (playerHand.length === HAND_SIZE_WIN) { // ãƒ„ãƒ¢ä¸ŠãŒã‚Š (é³´ã+ãƒ„ãƒ¢)
                    for (let i = 0; i < playerHand.length; i++) {
                        const eightTiles = [...playerHand.slice(0, i), ...playerHand.slice(i + 1)];
                        if (canFormYaku(eightTiles, playerOpenTiles.length)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * 8æšã®æ‰‹ç‰ŒãŒã€Œ3æšçµ„Ã—(2 + openSets)ã€ã¨ã€Œé›€é ­(2æšçµ„)Ã—1ã€ã§æ§‹æˆå¯èƒ½ã‹ã‚’åˆ¤å®š
         * openSetsCount: æ—¢ã«å…¬é–‹ã•ã‚Œã¦ã„ã‚‹3æšçµ„ã®æ•°
         * NOTE: ã“ã®ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ã§ã¯ã€å…¬é–‹ç‰Œã®ã‚»ãƒƒãƒˆæ•°ã«é–¢ã‚ã‚‰ãšã€æ‰‹ç‰Œä»¥å¤–ã®8æšã§ã‚¢ã‚¿ãƒã¨ã‚»ãƒƒãƒˆãŒä½œã‚Œã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ã¯è¤‡é›‘ã™ãã‚‹ãŸã‚ã€ä¸€æ—¦ã€ç°¡ç•¥åŒ–ã•ã‚ŒãŸãƒ«ãƒ¼ãƒ«ã§å‡¦ç†ã—ã¦ã„ã¾ã™ã€‚
         * æœ€çµ‚çš„ã«ã€æ‰‹ç‰Œã¨å…¬é–‹ç‰Œã‚’åˆã‚ã›ãŸå…¨ã¦ã®ç‰Œ(14æš=3ã‚»ãƒƒãƒˆ+é›€é ­)ã§æ§‹æˆã§ãã¦ã„ã‚‹ã‹ã‚’ç¢ºèªã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€
         * ç¾åœ¨ã®ç°¡ç•¥ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ãƒ«ãƒ¼ãƒ«(8æšã‚¹ã‚¿ãƒ¼ãƒˆã€3æšçµ„3çµ„+é›€é ­1çµ„=11æšãŒåŸºæœ¬)ã«åˆã‚ã›ã¦ã€
         * é³´ãã‚ã‚Šã®å ´åˆã¯ã€é³´ãã‚»ãƒƒãƒˆ+æ‰‹ç‰Œã§å®Œæˆå½¢ãŒä½œã‚Œã‚‹ã‹ã‚’è¦‹ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
         *
         * æœ¬ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã¯ã€**ã€Œå…¬é–‹ç‰Œã®ã‚»ãƒƒãƒˆæ•°ã«é–¢ã‚ã‚‰ãšã€æ‰‹ç‰Œ9æšï¼ˆãƒ„ãƒ¢ç›´å¾Œï¼‰ã‹ã‚‰1æšã‚’é›€é ­ã¨è¦‹ç«‹ã¦ãŸ8æšã§ã€æ®‹ã‚Š3æšçµ„ã‚’æ§‹æˆã§ãã‚‹ã‹ã€**ã¨ã„ã†ç°¡ç•¥åŒ–ã—ãŸãƒã‚§ãƒƒã‚¯æ–¹æ³•ã‚’ç¶­æŒã—ã¾ã™ã€‚
         */
        function canFormYaku(hand, openSetsCount = 0) {
             const requiredSetsInHand = 2; // æ‰‹ç‰Œã‹ã‚‰ä½œã‚‹3æšçµ„ã®æ•° (8æšã®æ‰‹ç‰Œã‹ã‚‰2ã‚»ãƒƒãƒˆã¨é›€é ­1çµ„)
             const requiredHandSize = 8;
             if (hand.length !== requiredHandSize) return false;

             const counts = {};
             let otaniCount = 0;
             hand.forEach(id => {
                 const type = id.substring(0, 2);
                 if (type === SPECIAL_TILE) {
                     otaniCount++;
                 } else {
                     counts[type] = (counts[type] || 0) + 1;
                 }
             });

             const uniqueTypes = Object.keys(counts);
             const allTypes = [...uniqueTypes, SPECIAL_TILE];

             // é›€é ­ï¼ˆ2æšçµ„ï¼‰ã‚’æ¢ã—ã€æ®‹ã‚Šã®6æšã§2ã‚»ãƒƒãƒˆï¼ˆ3æšçµ„Ã—2ï¼‰ã‚’æ§‹æˆã§ãã‚‹ã‹ãƒã‚§ãƒƒã‚¯
             for (const headType of allTypes) {
                 let tempOtaniCount = otaniCount;
                 let tempCounts = { ...counts };
                 let canFormHead = false;
                 
                 // å¤§è°·ç‰Œã®ã¿ã‚’é›€é ­ã¨ã—ã¦ä½¿ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ä»–ã®ç‰Œã¨ã®çµ„ã¿åˆã‚ã›ã§æ—¢ã«ã‚«ãƒãƒ¼ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã‚¹ã‚­ãƒƒãƒ—
                 if (headType === SPECIAL_TILE) continue;
                 
                 if (!tempCounts[headType] && headType !== SPECIAL_TILE) continue;

                 // é›€é ­ã‚’é€šå¸¸ç‰Œ2æšã§æ§‹æˆ
                 if (tempCounts[headType] >= 2) {
                     tempCounts[headType] -= 2;
                     canFormHead = true;
                 } 
                 // é›€é ­ã‚’é€šå¸¸ç‰Œ1æš+å¤§è°·ç‰Œ1æšã§æ§‹æˆ
                 else if (tempCounts[headType] >= 1 && tempOtaniCount >= 1) {
                     tempCounts[headType] -= 1;
                     tempOtaniCount -= 1;
                     canFormHead = true;
                 } 
                 
                 if (canFormHead) {
                     // é›€é ­ã‚’é™¤ã„ãŸæ®‹ã‚Šã®6æšï¼ˆ3æšçµ„Ã—2ï¼‰ã§æ§‹æˆå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                     const remainingTiles = [];
                     for (const type in tempCounts) {
                          for (let i = 0; i < tempCounts[type]; i++) {
                              remainingTiles.push(type); 
                          }
                     }
                     
                     if (canFormSets(remainingTiles, tempOtaniCount, requiredSetsInHand)) { 
                          return true;
                     }
                 }
             }

             return false;
        }
        
        /**
         * æ®‹ã‚Šã®æ‰‹ç‰ŒãŒå…¨ã¦3æšçµ„ã§æ§‹æˆå¯èƒ½ã‹ã‚’ãƒã‚§ãƒƒã‚¯ (å†å¸°é–¢æ•°)
         */
        function canFormSets(tiles, otaniCount, setsToFind) {
             if (setsToFind === 0) return tiles.length === 0;
             if (tiles.length + otaniCount < setsToFind * 3) return false;

             const counts = {};
             tiles.forEach(type => {
                 counts[type] = (counts[type] || 0) + 1;
             });

             const sortedTypes = Object.keys(counts).sort((a, b) => a.localeCompare(b));
             const firstType = sortedTypes.find(type => counts[type] > 0);
             if (!firstType) return otaniCount >= setsToFind * 3;

             let result = false;
             
             // æ¬¡ã®å†å¸°å‡¦ç†ã®ãŸã‚ã«æ®‹ã‚Šã®ç‰Œã‚’æº–å‚™ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
             const getNextTiles = (currentCounts) => {
                 const nextTiles = [];
                 for (const type in currentCounts) {
                      for (let i = 0; i < currentCounts[type]; i++) {
                          nextTiles.push(type);
                      }
                 }
                 return nextTiles;
             };

             // --- 1. åˆ»å­ (3æš) ã®æ§‹æˆ ---
             // 1-1. é€šå¸¸ç‰Œã®ã¿ã§æ§‹æˆ (3æš)
             if (counts[firstType] >= 3) {
                 counts[firstType] -= 3;
                 result = canFormSets(getNextTiles(counts), otaniCount, setsToFind - 1);
                 counts[firstType] += 3; // backtrack
                 if (result) return true;
             }

             // 1-2. å¤§è°·ç‰Œã‚’ä½¿ç”¨ã—ã¦æ§‹æˆ (2æš+å¤§è°·1 or 1æš+å¤§è°·2)
             if (otaniCount >= 1 && counts[firstType] >= 2) { // 2æš+å¤§è°·1
                 counts[firstType] -= 2;
                 result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                 counts[firstType] += 2; // backtrack
                 if (result) return true;
             }
             if (otaniCount >= 2 && counts[firstType] >= 1) { // 1æš+å¤§è°·2
                 counts[firstType] -= 1;
                 result = canFormSets(getNextTiles(counts), otaniCount - 2, setsToFind - 1);
                 counts[firstType] += 1; // backtrack
                 if (result) return true;
             }
             if (otaniCount >= 3) { // 0æš+å¤§è°·3
                 result = canFormSets(tiles, otaniCount - 3, setsToFind - 1);
                 if (result) return true;
             }
             
             // --- 2. é †å­ (é€£ç•ª3æš) ã®æ§‹æˆ ---
             const num1 = parseInt(firstType.substring(1));
             if (firstType.startsWith('P') && num1 >= 1 && num1 <= 7) {
                 const type2 = `P${num1 + 1}`;
                 const type3 = `P${num1 + 2}`;
                 
                 // 2-1. é€šå¸¸ç‰Œã®ã¿ã§æ§‹æˆ (P1, P2, P3)
                 if (counts[type2] > 0 && counts[type3] > 0) {
                      counts[firstType]--;
                      counts[type2]--;
                      counts[type3]--;
                      result = canFormSets(getNextTiles(counts), otaniCount, setsToFind - 1);
                      counts[firstType]++; counts[type2]++; counts[type3]++; // backtrack
                      if (result) return true;
                 }

                 // 2-2. å¤§è°·ç‰Œ1æšä½¿ç”¨ (ä¾‹: P1, P2, OT)
                 if (otaniCount >= 1) {
                    // P1, P2, OT
                    if (counts[firstType] > 0 && counts[type2] > 0) {
                        counts[firstType]--; counts[type2]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[firstType]++; counts[type2]++;
                        if (result) return true;
                    }

                    // P1, OT, P3
                    if (counts[firstType] > 0 && counts[type3] > 0) {
                        counts[firstType]--; counts[type3]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[firstType]++; counts[type3]++;
                        if (result) return true;
                    }
                    
                    // OT, P2, P3
                    if (counts[type2] > 0 && counts[type3] > 0) {
                        counts[type2]--; counts[type3]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[type2]++; counts[type3]++;
                        if (result) return true;
                    }
                 }
                 
                 // 2-3. å¤§è°·ç‰Œ2æšä½¿ç”¨ (ä¾‹: P1, OT, OT)
                 if (otaniCount >= 2) {
                    // P1, OT, OT
                    if (counts[firstType] > 0) {
                        counts[firstType]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 2, setsToFind - 1);
                        counts[firstType]++;
                        if (result) return true;
                    }
                 }
             }

             return false;
        }

        // -----------------------------------------------------
        // 5. ãƒãƒ£ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        async function sendMessage() {
            if (!isAuthReady || !roomId || !roomRef || !userId) return;

            const messageText = chatInput.value.trim();
            if (messageText === "") return;

            const newMessage = {
                senderId: userId,
                senderAlias: playerName || `User-${userId.substring(0, 4)}`, // ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’ä½¿ç”¨
                text: messageText,
                timestamp: Date.now()
            };

            try {
                await updateDoc(roomRef, {
                    messages: arrayUnion(newMessage)
                });
                chatInput.value = '';
            } catch (error) {
                console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        function renderMessages(messages) {
            messagesList.innerHTML = '';
            
            const msgs = messages.slice(-50); 
            
            msgs.forEach(msg => {
                const isMe = msg.senderId === userId;
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(isMe ? 'my-message' : 'other-message');
                
                const alias = msg.senderAlias || `User-${msg.senderId.substring(0, 4)}`;
                const time = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

                messageElement.innerHTML = `
                    <div class="message-header">
                        <span class="sender">${isMe ? 'ç§' : alias}</span>
                        <span class="time">${time}</span>
                    </div>
                    <div class="message-content">${msg.text}</div>
                `;
                messagesList.appendChild(messageElement);
            });
            messagesList.scrollTop = messagesList.scrollHeight;
        }
        
        function endGame(winnerId) {
            drawButton.disabled = true;
            checkButton.disabled = true;
            discardSelectedButton.style.display = 'none';
            callOpenSetButton.style.display = 'none';
            skipActionButton.style.display = 'none';

            if (winnerId) {
                 const winnerName = roomData.players.find(p => p.userId === winnerId)?.displayName || `User-${winnerId.substring(0, 4)}`;
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚å‹è€…: ${winnerId === userId ? 'ã‚ãªãŸ' : winnerName}`;
                 connectionStatus.style.backgroundColor = winnerId === userId ? '#00FF00' : '#FF0000';
            } else {
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚`;
                 connectionStatus.style.backgroundColor = '#AAAAAA';
            }
            
            if (unsubscribeRoom) {
                 unsubscribeRoom();
                 unsubscribeRoom = null;
            }
            setTimeout(() => {
                location.reload(); 
            }, 5000);
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = array[j][array[i]];
            }
        }

        
        // -----------------------------------------------------
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        // -----------------------------------------------------

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('set-name-button').addEventListener('click', setPlayerName);
            document.getElementById('create-room-button').addEventListener('click', createRoom);
            document.getElementById('join-room-button').addEventListener('click', () => joinRoom());
            document.getElementById('start-game-button').addEventListener('click', startGame);
            drawButton.onclick = drawTile;
            checkButton.onclick = checkHandForYaku;
            discardSelectedButton.onclick = discardSelectedTile;
            callOpenSetButton.onclick = callOpenSet; // é³´ããƒœã‚¿ãƒ³
            skipActionButton.onclick = skipAction;   // è¦‹é€ã‚Šãƒœã‚¿ãƒ³
            
            sendButton.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            initFirebase();
        });

    </script>
    <style>
        :root {
            --tile-bg: #fff;
            --tile-border: #333;
            --deck-bg: #556B2F; /* Olive Drab */
            --player-bg: #f4f4f9;
            --primary-color: #003366; /* Deep Blue (Baseball theme) */
            --secondary-color: #CC3333; /* Red (Baseball theme) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 700;
            letter-spacing: 2px;
            border-bottom: 3px solid var(--secondary-color);
            padding-bottom: 10px;
        }

        #game-container {
            display: none;
            gap: 20px;
            flex-wrap: wrap;
        }

        #game-content {
            flex-grow: 1;
            min-width: 450px;
        }
        
        /* ç‰Œã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        .tile {
            width: 45px;
            height: 60px;
            background-color: var(--tile-bg);
            border: 2px solid var(--tile-border);
            border-radius: 6px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* ç‰Œã®è‰²ä»˜ã‘ */
        .tile[data-type^="P1"] { color: #009999; background-color: #E0FFFF; } 
        .tile[data-type^="P2"] { color: #8B4513; background-color: #F5F5DC; } 
        .tile[data-type^="P3"] { color: #006400; background-color: #90EE90; } 
        .tile[data-type^="P4"] { color: #DAA520; background-color: #FAFAD2; } 
        .tile[data-type^="P5"] { color: #FF4500; background-color: #FFDAB9; } 
        .tile[data-type^="P6"] { color: #4169E1; background-color: #ADD8E6; } 
        .tile[data-type^="P7"] { color: #800080; background-color: #E6E6FA; } 
        .tile[data-type^="P8"] { color: #2F4F4F; background-color: #D3D3D3; } 
        .tile[data-type^="P9"] { color: #B8860B; background-color: #F0E68C; } 
        
        /* å¤§è°·ç‰Œ (ã‚ªãƒ¼ãƒ«ãƒã‚¤ãƒ†ã‚£) - ç”»åƒè¡¨ç¤º */
        .tile[data-type^="OT"] { 
            color: transparent; 
            background-color: #FFD700; /* Gold */
            border-color: var(--primary-color);
            font-size: 0; 
            background-size: 80% 80%;
            background-position: center;
            background-repeat: no-repeat;
            /* å¤§è°·é¸æ‰‹ã®ç”»åƒã¯è‘—ä½œæ¨©ã®é–¢ä¿‚ã§ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã«ç½®ãæ›ãˆã¾ã™ */
            background-image: url('https://placehold.co/45x60/FFD700/003366?text=OHTANI');
        }
        
        /* è£è¿”ã—ã®ç‰Œï¼ˆå±±æœ­/ç›¸æ‰‹æ‰‹ç‰Œï¼‰ */
        .tile.face-down {
            background-color: var(--deck-bg);
            border-color: #333;
            color: transparent;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            cursor: default;
        }
        .tile.face-down:hover { transform: none; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); }

        /* å…¬é–‹ç‰Œã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        .open-tiles-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px 0;
            min-height: 70px;
        }
        .open-tile-set {
            display: flex;
            margin-right: 15px; /* ã‚»ãƒƒãƒˆé–“ã®ã‚¹ãƒšãƒ¼ã‚¹ */
            border: 1px dashed #666;
            padding: 2px;
            border-radius: 4px;
        }
        .open-tile-set .tile {
            cursor: default;
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }


        /* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .board-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .discard-area, .deck-area {
            flex-basis: 48%;
            padding: 10px;
            border-radius: 8px;
            background-color: #e0e0e0;
            text-align: center;
        }

        .discard-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 70px;
            justify-content: center;
        }
        
        .deck-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            background-color: #d0e0d0;
        }

        .hand-area {
            background-color: var(--player-bg);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #ccc;
            margin-bottom: 15px;
        }

        .tile-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 70px;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #002244; transform: translateY(-1px); }
        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #a32727; transform: translateY(-1px); }
        
        .btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }
        
        .tile.selected {
            border: 4px solid var(--secondary-color);
            box-shadow: 0 0 10px var(--secondary-color);
            transform: translateY(-5px);
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #message-box {
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 700;
            min-height: 30px;
        }
        .message-success { background-color: #e6ffe6; color: var(--secondary-color); border: 1px solid var(--secondary-color); }
        .message-error { background-color: #ffe6e6; color: var(--primary-color); border: 1px solid var(--primary-color); }
        .message-normal { background-color: #f0f8ff; color: #444; border: 1px solid #aaa; }
        
        #connection-status {
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 10px;
            color: white;
            background-color: #ccc;
        }
        
        /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
        #lobby-container {
            text-align: center;
            display: none;
        }
        
        .input-group {
             margin-bottom: 15px;
             padding: 10px;
             border: 1px solid #eee;
             border-radius: 8px;
        }
        .input-group input {
            padding: 8px;
            margin-right: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        /* --- ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #chat-container {
            width: 300px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #f8f8f8;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }
        #messages-list {
            flex-grow: 1;
            height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px;
            scroll-behavior: smooth;
        }
        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 8px;
            max-width: 85%;
        }
        .my-message {
            background-color: #dcf8c6;
            align-self: flex-end;
            margin-left: auto;
        }
        .other-message {
            background-color: #ffffff;
            border: 1px solid #eee;
            align-self: flex-start;
        }
        .message-header {
            font-size: 0.75em;
            color: #888;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }
        .sender {
            font-weight: bold;
            color: var(--primary-color);
        }
        .message-content {
            word-wrap: break-word;
        }
        #chat-input-area {
            display: flex;
            gap: 5px;
        }
        #chat-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }
        #send-button {
            padding: 8px 12px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 800px) {
            #game-container {
                flex-direction: column;
            }
            #chat-container {
                width: 100%;
                margin-top: 20px;
                max-height: 300px;
            }
            .board-area {
                flex-direction: column;
            }
            .discard-area, .deck-area {
                flex-basis: 100%;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Firebaseãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ  é‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© (2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ)</h1>
    <p id="loading-message" style="text-align: center; font-weight: bold;">èªè¨¼ä¸­...</p>
    
    <!-- ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
    <div id="lobby-container">
        <div id="connection-status">åŒæœŸå¾…æ©Ÿä¸­...</div>
        
        <div class="input-group">
            <h2 style="color: #444;">ã‚ãªãŸã®åå‰ã‚’æ±ºã‚ã‚‹</h2>
            <input type="text" id="player-name-input" placeholder="ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’å…¥åŠ› (å¿…é ˆ)" maxlength="10">
            <button id="set-name-button" class="btn" style="background-color: #5cb85c; color: white;">åå‰ã‚’æ±ºå®š</button>
            <p id="set-name-message" style="font-size: 0.9em; color: #CC3333; margin-top: 5px;"></p>
        </div>
        <p id="player-name-display">ã‚ãªãŸã®åå‰: æœªè¨­å®š</p>
        <p id="user-id-display" style="font-size: 0.8em; color: #777;">å†…éƒ¨ID: ãƒ­ãƒ¼ãƒ‰ä¸­...</p>

        <div class="input-group">
            <h2 style="color: var(--secondary-color);">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</h2>
            <button id="create-room-button" class="btn btn-secondary" disabled>æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>
        <div class="input-group">
            <h2 style="color: var(--primary-color);">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </h2>
            <input type="text" id="room-id-input" placeholder="ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›" maxlength="8">
            <button id="join-room-button" class="btn btn-primary" disabled>å‚åŠ </button>
        </div>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ï¼†ãƒãƒ£ãƒƒãƒˆç”»é¢ -->
    <div id="game-container">
        
        <!-- ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ -->
        <div id="game-content" style="display: none;">
            <h2 id="room-title" style="text-align: center; margin-bottom: 5px;"></h2>
            <p id="player-list" style="text-align: center;"></p>

            <div id="message-box"></div>
            
            <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area" style="background-color: #e6e6e6;">
                <h2 style="margin-top: 0; color: #555;">å¯¾æˆ¦ç›¸æ‰‹ã®æ‰‹ç‰Œ</h2>
                <div id="opponent-open-tiles-container" class="open-tiles-area" style="justify-content: center;">
                    <!-- ç›¸æ‰‹ã®å…¬é–‹ç‰Œ -->
                </div>
                <div id="opponent-hand-container" class="tile-list" style="justify-content: center;">
                    <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œï¼ˆè£è¿”ã—ï¼‰ -->
                </div>
            </div>

            <div class="board-area">
                <!-- å±±æœ­ã‚¨ãƒªã‚¢ -->
                <div class="deck-area">
                    <p style="font-weight: 700;">å±±æœ­ (<span id="deck-count">48</span>)</p>
                    <div class="tile face-down"></div>
                </div>

                <!-- æ¨ã¦ç‰Œã‚¨ãƒªã‚¢ -->
                <div class="discard-area">
                    <p style="font-weight: 700;">æ¨ã¦ç‰Œ</p>
                    <div id="discard-container" class="discard-list">
                        <!-- æ¨ã¦ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area">
                <h2 style="margin-top: 0; color: #555;">ã‚ãªãŸã®æ‰‹ç‰Œ (<span id="hand-count">0</span>æš)</h2>
                <p id="current-turn" style="font-weight: bold; padding: 5px; border-radius: 4px; text-align: center;"></p>
                
                <h3 style="margin: 5px 0 5px 0; font-size: 1.1em; color: #444;">å…¬é–‹ã•ã‚ŒãŸ3æšçµ„</h3>
                <div id="open-tiles-container" class="open-tiles-area">
                    <!-- è‡ªåˆ†ã®å…¬é–‹ç‰Œ -->
                </div>

                <h3 style="margin: 5px 0 5px 0; font-size: 1.1em; color: #444;">æ‰‹ç‰Œ</h3>
                <div id="hand-container" class="tile-list">
                    <!-- ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>

            <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ -->
            <div class="controls">
                <button id="draw-button" class="btn btn-primary" disabled>å±±æœ­ã‹ã‚‰1æšå¼•ã</button>
                <button id="discard-selected-button" class="btn btn-primary" style="display: none;" disabled>é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã¦ã‚¿ãƒ¼ãƒ³çµ‚äº†</button>
                <button id="check-button" class="btn btn-secondary" disabled>å½¹ã‚’åˆ¤å®šã™ã‚‹</button>
                
                <!-- é³´ãã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ -->
                <button id="call-open-set-button" class="btn btn-secondary" style="display: none;">3æšçµ„ã‚’å…¬é–‹ã™ã‚‹ (é³´ã)</button>
                <button id="skip-action-button" class="btn btn-primary" style="display: none;">è¦‹é€ã‚‹</button>

                <button id="start-game-button" class="btn btn-secondary" style="display: none;">ã‚²ãƒ¼ãƒ é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿)</button>
            </div>
            <button class="btn" style="background-color: #777; color: white; margin-top: 15px;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>
        </div>
        
        <!-- ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒŠ -->
        <div id="chat-container">
            <h3 style="margin-top: 0; color: #555;">ãƒ«ãƒ¼ãƒ ãƒãƒ£ãƒƒãƒˆ</h3>
            <div id="messages-list">
                <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...">
                <button id="send-button" class="btn btn-secondary">é€ä¿¡</button>
            </div>
        </div>
    </div>

</div>

</body>
</html>
