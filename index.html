<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTCãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© - 2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght+400;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebaseã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, updateDoc, arrayUnion, arrayRemove, getDoc, runTransaction, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestoreã®ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š (ãƒ‡ãƒãƒƒã‚°ç”¨)
        setLogLevel('debug');

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆCanvasç’°å¢ƒã‹ã‚‰æä¾›ã•ã‚Œã‚‹ã‚‚ã®ã‚’å–å¾—ï¼‰
        // æä¾›ã•ã‚ŒãŸFirebaseè¨­å®šã‚’ç›´æ¥ä½¿ç”¨
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBPMqx8KHacF0XiRLSRztgXiRHoGdXFpCQ",
            authDomain: "talk-to-friends-point.firebaseapp.com",
            projectId: "talk-to-friends-point",
            storageBucket: "talk-to-friends-point.firebaseapp.com",
            messagingSenderId: "1012267135320",
            appId: "1:1012267135320:web:1bb99aa6249c88bfac752d",
            measurementId: "G-RFX7NK1Q28"
        };
        
        // Canvasç’°å¢ƒå¤‰æ•°ã¨çµ±åˆ
        const firebaseConfig = FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_CONFIG.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Firebaseã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let app;
        let db;
        let auth;
        let userId = 'loading';
        let isAuthReady = false;

        // WebRTC/ã‚²ãƒ¼ãƒ é–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const STUN_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
        let peerConnection;
        let dataChannel;
        let roomId = '';
        let roomRef = null;
        let roomData = null;
        let unsubscribeRoom = null;
        let isHost = false;
        let isConnectedP2P = false;
        /** * â˜…FIX: å‡¦ç†æ¸ˆã¿ã®ICEå€™è£œã‚’è¿½è·¡ã™ã‚‹ãŸã‚ã®Set
         */
        let processedIceCandidates = new Set();


        // ã‚²ãƒ¼ãƒ å®šæ•°
        const TILE_TYPES = ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9'];
        const SPECIAL_TILE = 'SP';
        const TILES_PER_TYPE = 4;
        const HAND_SIZE_START = 8;
        
        let playerHand = [];
        let isDrawingPhase = false; // true: ç‰Œã‚’å¼•ã„ãŸç›´å¾Œ (9æšçŠ¶æ…‹), false: ç‰Œã‚’æ¨ã¦ãŸç›´å¾Œ (8æšçŠ¶æ…‹)
        let selectedTileId = null;

        // DOMè¦ç´ ã®å–å¾—
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const drawButton = document.getElementById('draw-button');
        const checkButton = document.getElementById('check-button');
        const discardSelectedButton = document.getElementById('discard-selected-button');
        const handContainer = document.getElementById('hand-container');
        const opponentHandContainer = document.getElementById('opponent-hand-container');
        const deckCountDisplay = document.getElementById('deck-count');
        const discardContainer = document.getElementById('discard-container');
        const messageBox = document.getElementById('message-box');
        const connectionStatus = document.getElementById('connection-status');
        const currentTurnDisplay = document.getElementById('current-turn');
        const userIdDisplay = document.getElementById('user-id-display');
        
        // ãƒãƒ£ãƒƒãƒˆé–¢é€£DOMè¦ç´ 
        const messagesList = document.getElementById('messages-list');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');

        // -----------------------------------------------------
        // 1. FirebaseåˆæœŸåŒ–ã¨èªè¨¼
        // -----------------------------------------------------

        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        // åŒ¿åèªè¨¼
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    userIdDisplay.textContent = `ã‚ãªãŸã®ID: ${userId}`;
                    displayMessage("èªè¨¼å®Œäº†ã€‚ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã¾ãŸã¯å‚åŠ ã—ã¦ãã ã•ã„ã€‚", 'normal');
                    document.getElementById('loading-message').style.display = 'none';
                    lobbyContainer.style.display = 'block';
                });

                // ã‚«ã‚¹ã‚¿ãƒ èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                }

            } catch (error) {
                console.error("FirebaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("FirebaseåˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        // -----------------------------------------------------
        // 2. ãƒ«ãƒ¼ãƒ ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function getRoomCollectionRef() {
            // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³: /artifacts/{appId}/public/data/donjara_rooms
            return collection(db, 'artifacts', appId, 'public', 'data', 'donjara_rooms');
        }

        /**
         * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ–
         */
        function createInitialRoomData() {
            // å…¨ã¦ã®ç‰Œã‚’ç”Ÿæˆ
            let initialDeck = [];
            for (const type of TILE_TYPES) {
                for (let i = 1; i <= TILES_PER_TYPE; i++) {
                    initialDeck.push(`${type}-${i}`);
                }
            }
            for (let i = 1; i <= TILES_PER_TYPE; i++) {
                 initialDeck.push(`${SPECIAL_TILE}-${i}`);
            }
            shuffle(initialDeck);

            return {
                players: [],
                deck: initialDeck,
                discardedTiles: [],
                currentPlayerId: '',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                signaling: {},
                messages: [], // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ ¼ç´ç”¨
                lastUpdated: Date.now()
            };
        }

        /**
         * ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã€ãƒ›ã‚¹ãƒˆã¨ã—ã¦å‚åŠ 
         */
        async function createRoom() {
            if (!isAuthReady) return;

            roomId = crypto.randomUUID().substring(0, 8);
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = true;
            isConnectedP2P = false;

            try {
                await setDoc(roomRef, createInitialRoomData());
                await joinRoom(roomId);
            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        /**
         * ãƒ«ãƒ¼ãƒ ã«å‚åŠ 
         */
        async function joinRoom(id) {
            if (!isAuthReady) return;
            roomId = id || document.getElementById('room-id-input').value.trim();
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = false; // å‚åŠ è€…ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
            isConnectedP2P = false;

            if (!roomId) {
                displayMessage("ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", 'error');
                return;
            }

            try {
                // æ—¢å­˜ã®ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const roomSnapshot = await getDoc(roomRef);
                if (!roomSnapshot.exists()) {
                    displayMessage(`ãƒ«ãƒ¼ãƒ ID: ${roomId} ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`, 'error');
                    return;
                }

                // å‚åŠ å‡¦ç†ã‚’ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å®Ÿè¡Œ (ç«¶åˆå›é¿)
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.status !== 'waiting' || currentRoomData.players.length >= 2) {
                        throw new Error("ã“ã®ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã‹ã€æ—¢ã«ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                    }
                    
                    // æ—¢ã«ãƒ«ãƒ¼ãƒ ã«ã„ã‚‹å ´åˆã¯è¿½åŠ ã—ãªã„
                    if (currentRoomData.players.some(p => p.userId === userId)) {
                        return;
                    }

                    // 1äººç›®ãªã‚‰ãƒ›ã‚¹ãƒˆã€2äººç›®ãªã‚‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
                    const isNewHost = currentRoomData.players.length === 0;
                    const newPlayer = { userId, hand: [], isHost: isNewHost };
                    const newPlayers = [...currentRoomData.players, newPlayer];

                    transaction.update(roomRef, {
                        players: newPlayers,
                        signaling: { ...currentRoomData.signaling, [userId]: { iceCandidates: [] } } // ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æƒ…å ±ã®åˆæœŸåŒ–
                    });
                });

                // UIåˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('room-title').textContent = `ãƒ«ãƒ¼ãƒ ID: ${roomId}`;
                lobbyContainer.style.display = 'none';
                gameContainer.style.display = 'flex'; // Flexboxã«å¤‰æ›´
                document.getElementById('game-content').style.display = 'block';

                // ãƒ«ãƒ¼ãƒ ã®å¤‰æ›´ã‚’ç›£è¦–é–‹å§‹
                startRoomListener();

            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ãƒ«ãƒ¼ãƒ å‚åŠ å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        /**
         * ãƒ«ãƒ¼ãƒ ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
         */
        function startRoomListener() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            unsubscribeRoom = onSnapshot(roomRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const oldStatus = roomData ? roomData.status : 'unknown';
                    roomData = docSnapshot.data();
                    const newStatus = roomData.status;
                    
                    // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®æ‰‹ç‰ŒåˆæœŸåŒ–å‡¦ç†ã‚’è¿½åŠ 
                    if (newStatus === 'playing' && oldStatus !== 'playing') {
                        const myState = roomData.players.find(p => p.userId === userId);
                        
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹ç‰ŒãŒåˆæœŸé…ç‰Œã‚µã‚¤ã‚º(8æš)ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
                        if (myState && myState.hand.length === HAND_SIZE_START && playerHand.length === 0) {
                            playerHand = myState.hand;
                            isDrawingPhase = false; // æœ€åˆã¯8æšãªã®ã§ã€ç‰Œã‚’å¼•ãå‰ã®çŠ¶æ…‹
                            updateUI(); 
                            displayMessage("ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã—ã¾ã—ãŸï¼ã‚ãªãŸã®ç•ªã‹ã‚‰ç‰Œã‚’å¼•ã„ã¦ãã ã•ã„ã€‚", 'success');
                        }
                    } else if (newStatus === 'finished') {
                        // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã®å‡¦ç†
                        displayMessage("ã‚²ãƒ¼ãƒ ãŒçµ‚äº†ã—ã¾ã—ãŸã€‚ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚Šã¾ã™ã€‚", 'normal');
                        endGame(roomData.winnerId || null);
                        return;
                    }

                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã®æ›´æ–°
                    const playersInfo = roomData.players.map(p => 
                        `${p.userId === userId ? 'ã‚ãªãŸ (Me)' : 'å¯¾æˆ¦ç›¸æ‰‹ (Opponent)'} ${p.isHost ? '(HOST)' : ''}`
                    ).join(' / ');
                    document.getElementById('player-list').textContent = playersInfo;

                    if (roomData.players.length === 2 && newStatus === 'waiting') {
                        // 2äººæƒã£ãŸã‚‰WebRTCæ¥ç¶šã‚’é–‹å§‹
                        if (!peerConnection) {
                             startWebRTCConnection();
                        }
                    } 
                    
                    // ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å‡¦ç† (æ¥ç¶šç¢ºç«‹ã¾ã§)
                    handleSignaling();

                    // ã‚²ãƒ¼ãƒ UIã®æ›´æ–° (ãƒ«ãƒ¼ãƒ IDè¡¨ç¤ºã€ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºãªã©)
                    updateGameUI(roomData);
                    
                    // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ›´æ–°
                    if (roomData.messages) {
                        renderMessages(roomData.messages);
                    }

                } else {
                    displayMessage("ãƒ«ãƒ¼ãƒ ã¯å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚", 'error');
                    // ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹å‡¦ç†
                    if (unsubscribeRoom) {
                        unsubscribeRoom();
                        unsubscribeRoom = null;
                    }
                    location.reload(); 
                }
            });
        }
        
        /**
         * ã‚²ãƒ¼ãƒ ã®é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿å®Ÿè¡Œ)
         */
        async function startGame() {
            if (!isHost || roomData.status !== 'waiting' || roomData.players.length !== 2) return;

            // åˆæœŸé…ç‰Œã¨åˆæœŸã‚¿ãƒ¼ãƒ³ã®è¨­å®š
            const players = roomData.players.map(p => ({ ...p, hand: [] }));
            let deck = [...roomData.deck];

            // 8æšé…ã‚‹
            for (let i = 0; i < HAND_SIZE_START; i++) {
                players.forEach(p => {
                    // å±±æœ­ã‹ã‚‰å–ã‚Šå‡ºã™
                    const tile = deck.pop();
                    if(tile) p.hand.push(tile); 
                });
            }

            // å…ˆæ”»ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
            const startingPlayerId = players[Math.floor(Math.random() * 2)].userId;

            try {
                await updateDoc(roomRef, {
                    players: players,
                    deck: deck,
                    currentPlayerId: startingPlayerId,
                    status: 'playing',
                    lastUpdated: Date.now()
                });
                displayMessage("ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼", 'success');
            } catch (error) {
                console.error("ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
            }
        }
        
        // -----------------------------------------------------
        // 3. WebRTCã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã¨æ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function startWebRTCConnection() {
            connectionStatus.textContent = 'æ¥ç¶šä¸­... (WebRTC/DataChannel)';
            connectionStatus.style.backgroundColor = '#FFD700'; // Gold

            // æ¥ç¶šè©¦è¡Œæ™‚ã«Setã‚’ã‚¯ãƒªã‚¢
            processedIceCandidates = new Set();
            
            peerConnection = new RTCPeerConnection({ iceServers: STUN_SERVERS });
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Local ICE Candidate Generated:', event.candidate.type);
                    // ICEå€™è£œã‚’Firestoreã«ä¿å­˜
                    saveIceCandidate(event.candidate.toJSON());
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                console.log('RTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    handleP2PConnected();
                } else if (peerConnection.connectionState === 'failed') {
                    console.error("WebRTCæ¥ç¶šå¤±æ•—ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯è¨­å®šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");
                    connectionStatus.textContent = 'æ¥ç¶šå¤±æ•—';
                    connectionStatus.style.backgroundColor = '#FF4500';
                }
            };

            // ãƒ›ã‚¹ãƒˆã¯DataChannelã‚’ä½œæˆ
            if (isHost) {
                dataChannel = peerConnection.createDataChannel("gameChannel");
                setupDataChannelListeners(dataChannel);
                createOffer();
            } else {
                // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯DataChannelã‚’å—ã‘å…¥ã‚Œã‚‹
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelListeners(dataChannel);
                };
            }
        }

        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                console.log('Created Offer:', offer.type);
                // Offerã‚’Firestoreã«ä¿å­˜
                await updateDoc(roomRef, {
                    [`signaling.${userId}.offer`]: peerConnection.localDescription.toJSON()
                });
            } catch (e) { console.error('Create Offer Error:', e); }
        }

        async function createAnswer(offer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                console.log('Created Answer:', answer.type);
                // Answerã‚’Firestoreã«ä¿å­˜
                await updateDoc(roomRef, {
                    [`signaling.${userId}.answer`]: peerConnection.localDescription.toJSON()
                });
            } catch (e) { console.error('Create Answer Error:', e); }
        }

        async function saveIceCandidate(candidate) {
            try {
                await updateDoc(roomRef, {
                    [`signaling.${userId}.iceCandidates`]: arrayUnion(candidate)
                });
            } catch (e) { console.error('Save ICE Candidate Error:', e); }
        }

        /**
         * Firestoreã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æƒ…å ±ã®å‡¦ç†
         */
        function handleSignaling() {
            if (isConnectedP2P) return;

            const opponent = roomData.players.find(p => p.userId !== userId);
            if (!opponent || !roomData.signaling || !roomData.signaling[opponent.userId]) return;

            const opponentSignal = roomData.signaling[opponent.userId];
            const mySignal = roomData.signaling[userId];
            
            // 1. Offerã®å‡¦ç† (ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´)
            if (!isHost && opponentSignal.offer && !peerConnection.remoteDescription) {
                console.log('Received Offer, creating Answer...');
                createAnswer(opponentSignal.offer);
            }

            // 2. Answerã®å‡¦ç† (ãƒ›ã‚¹ãƒˆå´)
            // hostãŒAnswerã‚’å—ã‘å–ã£ãŸãŒã€ã¾ã  remoteDescription ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆ
            if (isHost && opponentSignal.answer && (!peerConnection.remoteDescription || peerConnection.remoteDescription.type !== 'answer')) {
                console.log('Received Answer, setting Remote Description...');
                peerConnection.setRemoteDescription(new RTCSessionDescription(opponentSignal.answer)).catch(e => console.error('Error setting remote answer:', e));
            }
            
            // 3. ICEå€™è£œã®å‡¦ç†
            if (opponentSignal.iceCandidates && opponentSignal.iceCandidates.length > 0) {
                opponentSignal.iceCandidates.forEach(candidate => {
                    const candidateId = JSON.stringify(candidate);
                    // â˜…FIX: æ—¢ã«å‡¦ç†æ¸ˆã¿ã®å€™è£œã‹ãƒã‚§ãƒƒã‚¯
                    if (!processedIceCandidates.has(candidateId)) {
                        const ice = new RTCIceCandidate(candidate);
                        // remoteDescriptionãŒè¨­å®šã•ã‚Œã¦ã„ãªã„ã¨ICEå€™è£œã¯è¿½åŠ ã§ããªã„ãŸã‚ã€ãƒã‚§ãƒƒã‚¯
                        if (peerConnection.remoteDescription) {
                             peerConnection.addIceCandidate(ice).then(() => {
                                console.log('Added new ICE candidate.');
                                processedIceCandidates.add(candidateId);
                             }).catch(e => {
                                 console.warn('Error adding received ICE candidate (may be harmless):', e);
                                 // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã§ã‚‚ã‚»ãƒƒãƒˆã«è¿½åŠ ã—ã¦ãŠãã€å†è©¦è¡Œã‚’é¿ã‘ã‚‹
                                 processedIceCandidates.add(candidateId);
                             });
                        } else {
                            console.log('Remote description not set yet, skipping ICE candidate addition temporarily.');
                        }
                    }
                });
            }
        }
        
        /**
         * P2Pæ¥ç¶šå®Œäº†æ™‚ã®å‡¦ç†
         */
        function handleP2PConnected() {
            isConnectedP2P = true;
            connectionStatus.textContent = 'æ¥ç¶šå®Œäº† (DataChannel)';
            connectionStatus.style.backgroundColor = '#4CAF50'; // Green

            // 2äººæƒã£ã¦ã„ã‚Œã°ãƒ›ã‚¹ãƒˆãŒã‚²ãƒ¼ãƒ é–‹å§‹
            if (isHost && roomData.players.length === 2 && roomData.status === 'waiting') {
                startGame();
            }
        }
        
        // -----------------------------------------------------
        // 4. DataChannelé€šä¿¡ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function setupDataChannelListeners(channel) {
            channel.onopen = () => {
                console.log("Data Channel Opened");
                handleP2PConnected(); // æ¥ç¶šå®Œäº†ã‚’æ”¹ã‚ã¦ç¢ºèª
            };
            
            channel.onclose = () => {
                console.log("Data Channel Closed");
                isConnectedP2P = false;
                connectionStatus.textContent = 'åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ';
                connectionStatus.style.backgroundColor = '#FF4500'; // OrangeRed
            };
            
            channel.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleDataChannelMessage(message);
            };
            
            channel.onerror = (error) => {
                console.error("Data Channel Error:", error);
            };
        }
        
        /**
         * P2PçµŒç”±ã§ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
         */
        function sendGameAction(actionType, payload = {}) {
            if (isConnectedP2P && dataChannel.readyState === 'open') {
                const message = {
                    type: actionType,
                    senderId: userId,
                    payload
                };
                dataChannel.send(JSON.stringify(message));
            } else {
                // P2Pæœªæ¥ç¶šæ™‚ã¯FirestoreçµŒç”±ã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è©¦ã¿ã‚‹ï¼ˆç°¡æ˜“ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                // ã“ã“ã§ã¯P2Pæ¥ç¶šã‚’å¿…é ˆã¨ã—ã€é€ä¿¡å¤±æ•—ã®è­¦å‘Šã®ã¿
                console.warn("P2Pæ¥ç¶šãªã—ã€‚ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã«å¤±æ•—ã€ã¾ãŸã¯FirestoreåŒæœŸå¾…ã¡ã€‚");
            }
        }
        
        /**
         * P2PçµŒç”±ã§å—ã‘å–ã£ãŸã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†
         */
        function handleDataChannelMessage(message) {
            if (message.senderId === userId) return; // è‡ªåˆ†ãŒé€ã£ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–
            
            switch (message.type) {
                case 'GAME_STATE_SYNC':
                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹å…¨ä½“ã‚’åŒæœŸ (ã“ã“ã§ã¯ä½¿ã‚ãªã„ãŒã€å°†æ¥ã®æ‹¡å¼µç”¨)
                    break;
                case 'DRAW_TILE':
                    // ç›¸æ‰‹ãŒç‰Œã‚’å¼•ã„ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    opponentDrawTile(message.payload.tileId, message.payload.newDeck);
                    break;
                case 'DISCARD_TILE':
                    // ç›¸æ‰‹ãŒç‰Œã‚’æ¨ã¦ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    opponentDiscardTile(message.payload.tileId, message.payload.newHand, message.payload.nextPlayerId);
                    break;
                case 'YAKU_CHECK':
                    // ç›¸æ‰‹ãŒå½¹åˆ¤å®šã‚’ã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    displayMessage(`å¯¾æˆ¦ç›¸æ‰‹ãŒå½¹ã®åˆ¤å®šã‚’ã—ã¾ã—ãŸ: ${message.payload.isYaku ? 'æˆç«‹ï¼ã‚²ãƒ¼ãƒ çµ‚äº†' : 'ä¸æˆç«‹'}`, message.payload.isYaku ? 'success' : 'error');
                    if (message.payload.isYaku) {
                        endGame(message.payload.winnerId);
                    }
                    break;
                default:
                    console.warn("Unknown message type:", message.type);
            }
        }
        
        // -----------------------------------------------------
        // 5. ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (WebRTCåŒæœŸå¯¾å¿œ)
        // -----------------------------------------------------

        /**
         * UIã®æ›´æ–° (ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã«ä¾å­˜)
         */
        function updateGameUI(data) {
            if (!data || data.status !== 'playing') {
                currentTurnDisplay.textContent = 'ã‚²ãƒ¼ãƒ å¾…ã¡';
                currentTurnDisplay.style.backgroundColor = '#ccc';
                drawButton.disabled = true;
                checkButton.disabled = true;
                discardSelectedButton.style.display = 'none';
                return;
            }

            const myTurn = data.currentPlayerId === userId;
            const opponentPlayerState = data.players.find(p => p.userId !== userId);
            
            // ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
            currentTurnDisplay.textContent = myTurn ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
            currentTurnDisplay.style.backgroundColor = myTurn ? '#aaffaa' : '#ffaaaa';
            
            // ãƒœã‚¿ãƒ³åˆ¶å¾¡
            // ç‰Œã‚’å¼•ããƒœã‚¿ãƒ³: è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ AND ç‰Œã‚’å¼•ã„ã¦ã„ãªã„çŠ¶æ…‹ AND å±±æœ­ãŒã‚ã‚‹
            drawButton.disabled = !myTurn || isDrawingPhase || data.deck.length === 0;
            // å½¹åˆ¤å®šãƒœã‚¿ãƒ³: è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ AND ç‰Œã‚’å¼•ã„ãŸçŠ¶æ…‹ (9æš)
            checkButton.disabled = !myTurn || playerHand.length !== HAND_SIZE_START + 1; // 8æš+1æš
            // æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã®è¡¨ç¤º: è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ AND ç‰Œã‚’å¼•ã„ãŸçŠ¶æ…‹ (9æš)
            discardSelectedButton.style.display = (myTurn && isDrawingPhase && selectedTileId) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTileId;
            
            // å±±æœ­ã¨æ¨ã¦ç‰Œ
            deckCountDisplay.textContent = data.deck.length;
            renderDiscardedTiles(data.discardedTiles);

            // ç›¸æ‰‹ã®æ‰‹ç‰Œ (è£è¿”ã—)
            opponentHandContainer.innerHTML = '';
            if (opponentPlayerState) {
                // ç›¸æ‰‹ã®æ‰‹ç‰Œã®æšæ•°ã ã‘è£è¿”ã—ã®ç‰Œã‚’è¡¨ç¤º
                const opponentHandSize = opponentPlayerState.hand.length;
                for (let i = 0; i < opponentHandSize; i++) {
                    opponentHandContainer.appendChild(Object.assign(document.createElement('div'), { className: 'tile face-down' }));
                }
            }

            // ãƒ›ã‚¹ãƒˆã¯ã‚²ãƒ¼ãƒ é–‹å§‹ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (isHost && data.players.length === 2 && data.status === 'waiting') {
                document.getElementById('start-game-button').style.display = 'block';
            } else {
                 document.getElementById('start-game-button').style.display = 'none';
            }
        }

        /**
         * ç‰ŒDOMè¦ç´ ã®ç”Ÿæˆ
         */
        function createTileElement(tileId, selectable = true) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.setAttribute('data-id', tileId);
            tile.setAttribute('data-type', tileId.substring(0, 2));
            tile.textContent = tileId.substring(1, 2) === 'P' ? 'â˜…' : tileId.substring(1, 2);

            if (selectable) {
                tile.addEventListener('click', handleTileClick);
            }
            return tile;
        }
        
        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
         */
        function displayMessage(text, type = 'normal') {
            messageBox.textContent = text;
            messageBox.className = '';
            messageBox.classList.add('message-box');
            if (type === 'success') {
                messageBox.classList.add('message-success');
            } else if (type === 'error') {
                messageBox.classList.add('message-error');
            } else {
                 messageBox.classList.add('message-normal');
            }
        }

        /**
         * æ‰‹ç‰ŒUIã‚’æ›´æ–°
         */
        function updateUI() {
            // æ‰‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            handContainer.innerHTML = '';
            playerHand.sort((a, b) => a.localeCompare(b));
            playerHand.forEach(tileId => {
                const tileEl = createTileElement(tileId);
                if (tileId === selectedTileId) {
                     tileEl.classList.add('selected');
                }
                handContainer.appendChild(tileEl);
            });
            
            // é¸æŠçŠ¶æ…‹ã®æ›´æ–°ã«å¿œã˜ã¦æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã‚’åˆ¶å¾¡ (updateGameUIã§ã‚‚åˆ¶å¾¡ã—ã¦ã„ã‚‹ãŒã€å³æ™‚ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã®ãŸã‚ã«ã“ã“ã§ã‚‚å®Ÿè¡Œ)
            const selectedTile = handContainer.querySelector('.tile.selected');
            discardSelectedButton.style.display = (roomData && roomData.currentPlayerId === userId && isDrawingPhase && selectedTile) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTile;
            
            document.getElementById('hand-count').textContent = playerHand.length;
        }
        
        /**
         * æ¨ã¦ç‰Œã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
         */
        function renderDiscardedTiles(tiles) {
            discardContainer.innerHTML = '';
            // æœ€æ–°ã®15æšã‚’è¡¨ç¤º
            tiles.slice(-15).forEach(tileId => {
                 discardContainer.appendChild(createTileElement(tileId, false));
            });
        }

        /**
         * ç‰Œã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç† (é¸æŠ)
         */
        function handleTileClick(event) {
            // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã§ã€ã‹ã¤ç‰Œã‚’å¼•ã„ãŸå¾Œ (9æšçŠ¶æ…‹) ã§ã®ã¿é¸æŠå¯èƒ½
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase) {
                displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã€ç‰Œã‚’å¼•ã„ãŸå¾Œã§ã®ã¿æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã§ãã¾ã™ã€‚", 'error');
                return;
            }

            const tileElement = event.currentTarget;
            const tileId = tileElement.getAttribute('data-id');

            const isSelected = tileElement.classList.contains('selected');
            
            // å…¨ã¦ãƒªã‚»ãƒƒãƒˆ
            handContainer.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            selectedTileId = null;

            if (!isSelected) {
                // æ–°ã—ãé¸æŠ
                tileElement.classList.add('selected');
                selectedTileId = tileId;
                displayMessage(`${tileId.substring(0, 2)}ã®ç‰Œã‚’é¸æŠã—ã¾ã—ãŸã€‚ã“ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€å½¹åˆ¤å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚`);
            } else {
                displayMessage("æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
            }
            updateGameUI(roomData); // æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–°
        }

        // -----------------------------------------------------
        // 6. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        // -----------------------------------------------------
        
        /**
         * å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã
         */
        async function drawTile() {
            if (!roomData || roomData.currentPlayerId !== userId || isDrawingPhase || roomData.deck.length === 0) return;
            
            let drawnTile = null;

            try {
                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å±±æœ­ã‹ã‚‰1æšå¼•ã
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId || currentRoomData.deck.length === 0) {
                        throw new Error("ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€ã¾ãŸã¯å±±æœ­ãŒç©ºã§ã™ã€‚");
                    }

                    drawnTile = currentRoomData.deck.pop();
                    const newDeck = currentRoomData.deck;
                    
                    const myPlayerIndex = currentRoomData.players.findIndex(p => p.userId === userId);
                    currentRoomData.players[myPlayerIndex].hand.push(drawnTile);

                    transaction.update(roomRef, {
                        deck: newDeck,
                        players: currentRoomData.players,
                        lastUpdated: Date.now()
                    });
                });

                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã®ãƒ­ãƒ¼ã‚«ãƒ«æ›´æ–°
                if (drawnTile) {
                    playerHand.push(drawnTile);
                    isDrawingPhase = true;
                    selectedTileId = null; // æ–°ã—ãå¼•ã„ãŸç‰ŒãŒè‡ªå‹•çš„ã«é¸æŠã•ã‚Œãªã„ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
                    updateUI();
                    updateGameUI(roomData);
                    displayMessage("å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ãã¾ã—ãŸ (æ‰‹ç‰Œ9æš)ã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", 'success');
                    
                    // P2Pã§ç›¸æ‰‹ã«ã‚‚é€šçŸ¥
                    sendGameAction('DRAW_TILE', { tileId: drawnTile, newDeck: roomData.deck });
                }

            } catch (error) {
                console.error("ç‰Œã‚’å¼•ãã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ç‰Œã‚’å¼•ãã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        /**
         * ç›¸æ‰‹ãŒç‰Œã‚’å¼•ã„ãŸæ™‚ã®å‡¦ç†
         */
        function opponentDrawTile(tileId, newDeck) {
            const opponent = roomData.players.find(p => p.userId !== userId);
            if (opponent) {
                // ç›¸æ‰‹ã®æ‰‹æœ­ã¯è¦‹ãŸç›®ä¸Šå¢—ãˆã‚‹ãŒã€ä¸­èº«ã¯åˆ†ã‹ã‚‰ãªã„
                opponent.hand.push('???'); 
            }
            // P2Pãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ã¯NewDeckãŒå…¥ã£ã¦ã„ã‚‹ãŒã€Firestoreã®ãƒªã‚¹ãƒŠãƒ¼ãŒæ›´æ–°ã™ã‚‹ã®ã§UIæ›´æ–°ã®ã¿
            updateGameUI(roomData);
            displayMessage("å¯¾æˆ¦ç›¸æ‰‹ãŒç‰Œã‚’å¼•ãã¾ã—ãŸã€‚");
        }

        /**
         * é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹
         */
        async function discardSelectedTile() {
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase || !selectedTileId) return;

            const tileIdToDiscard = selectedTileId;

            // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’æ±ºå®š
            const opponentId = roomData.players.find(p => p.userId !== userId).userId;
            const nextPlayerId = opponentId;

            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId) {
                        throw new Error("ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚");
                    }
                    
                    const myPlayerIndex = currentRoomData.players.findIndex(p => p.userId === userId);
                    const currentHand = currentRoomData.players[myPlayerIndex].hand;
                    
                    const tileIndex = currentHand.indexOf(tileIdToDiscard);
                    if (tileIndex === -1) {
                         throw new Error("æ¨ã¦ã‚‹ç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    }
                    
                    // Firestoreã®é…åˆ—ã‹ã‚‰å‰Šé™¤
                    currentHand.splice(tileIndex, 1);
                    currentRoomData.discardedTiles.push(tileIdToDiscard);

                    transaction.update(roomRef, {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        currentPlayerId: nextPlayerId,
                        lastUpdated: Date.now()
                    });
                    
                    // P2Pã§ç›¸æ‰‹ã«ã‚‚é€šçŸ¥ (ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ã¯Firestoreã®æ‰‹ç‰Œã¯æ›´æ–°ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãã‚Œã‚’é€ä¿¡)
                    sendGameAction('DISCARD_TILE', { 
                        tileId: tileIdToDiscard, 
                        // P2Pã§ã¯éå…¬é–‹ã®æ‰‹ç‰Œå†…å®¹ã¯é€ã‚‰ãªã„ãŒã€ç›¸æ‰‹ã®æ‰‹ç‰Œæšæ•°æ›´æ–°ã®ãŸã‚ã«ç©ºãƒªã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹
                        // ä»£ã‚ã‚Šã«ã€è‡ªåˆ†ã®ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’æ›´æ–°
                        nextPlayerId: nextPlayerId
                    });
                });

                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã®ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–°
                const localTileIndex = playerHand.indexOf(tileIdToDiscard);
                if (localTileIndex !== -1) {
                    playerHand.splice(localTileIndex, 1);
                }
                
                roomData.discardedTiles.push(tileIdToDiscard);
                roomData.currentPlayerId = nextPlayerId;
                
                isDrawingPhase = false;
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                displayMessage(`ç‰Œ(${tileIdToDiscard.substring(0,2)})ã‚’æ¨ã¦ã¾ã—ãŸã€‚ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`);

            } catch (error) {
                 console.error("ç‰Œã‚’æ¨ã¦ã‚‹ã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`ç‰Œã‚’æ¨ã¦ã‚‹ã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }
        
        /**
         * ç›¸æ‰‹ãŒç‰Œã‚’æ¨ã¦ãŸæ™‚ã®å‡¦ç†
         */
        function opponentDiscardTile(tileId, opponentNewHand, nextPlayerId) {
            roomData.discardedTiles.push(tileId);
            
            // ç›¸æ‰‹ã®æ‰‹ç‰Œã‚’1æšæ¸›ã‚‰ã™ (ãƒ€ãƒŸãƒ¼)
            const opponent = roomData.players.find(p => p.userId !== userId);
            if (opponent) {
                // ç›¸æ‰‹ã®æ‰‹ç‰Œã®æšæ•°æƒ…å ±ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã€Firestoreã®roomDataã‚’å‚ç…§
            }

            updateGameUI(roomData);
            displayMessage(`å¯¾æˆ¦ç›¸æ‰‹ãŒ${tileId.substring(0, 2)}ã®ç‰Œã‚’æ¨ã¦ã¾ã—ãŸã€‚ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`, 'success');
        }

        /**
         * å½¹ã®åˆ¤å®šã‚’å®Ÿè¡Œ
         */
        async function checkHandForYaku() {
            if (!roomData || roomData.currentPlayerId !== userId || playerHand.length !== HAND_SIZE_START + 1) return;

            const isYaku = checkYaku(playerHand);

            // P2Pã§ç›¸æ‰‹ã«é€šçŸ¥
            sendGameAction('YAKU_CHECK', { isYaku: isYaku, winnerId: isYaku ? userId : null });

            if (isYaku) {
                displayMessage("ğŸ‰ å½¹ãŒæˆç«‹ã—ã¾ã—ãŸï¼(3æšçµ„3ã¤) ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰", 'success');
                endGame(userId);
            } else {
                displayMessage("å½¹ã¯æˆç«‹ã—ã¦ã„ã¾ã›ã‚“ã€‚åˆ¥ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€è«¦ã‚ã¦ãã ã•ã„ã€‚", 'error');
            }
        }
        
        /**
         * å½¹ã®åˆ¤å®š (3æšçµ„3ã¤ - ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯)
         */
        function checkYaku(hand) {
            // NOTE: ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ã®å½¹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã¯éå¸¸ã«è¤‡é›‘ãªãŸã‚ã€ã“ã“ã§ã¯ç°¡æ˜“çš„ãªãƒ­ã‚¸ãƒƒã‚¯ã®ã¿ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
            // 9æšã®æ‰‹ç‰Œã§ã€ç‰¹æ®Šç‰Œã‚’å«ã‚ã¦3æšçµ„ãŒ3ã¤ã§ãã¦ã„ã‚‹ã‹ï¼ˆåˆ»å­ã¾ãŸã¯é †å­ï¼‰ã‚’åˆ¤å®šã—ã¾ã™ã€‚
            
            if (hand.length !== HAND_SIZE_START + 1) return false;
            
            // ç‰Œã®ã‚¿ã‚¤ãƒ—ã¨æ˜Ÿã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            const tileMap = {};
            let spCount = 0;
            
            hand.forEach(id => {
                const type = id.substring(0, 2);
                if (type === SPECIAL_TILE) {
                    spCount++;
                } else {
                    tileMap[type] = (tileMap[type] || 0) + 1;
                }
            });
            
            let tiles = Object.entries(tileMap).sort((a, b) => a[0].localeCompare(b[0]));
            
            // 3æšçµ„ã‚’è²ªæ¬²æ³•ã§æ¢ã™ (éå¸¸ã«ç°¡æ˜“çš„ãªåˆ¤å®šã§ã‚ã‚Šã€å®Œå…¨ãªãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ãƒ­ã‚¸ãƒƒã‚¯ã§ã¯ã‚ã‚Šã¾ã›ã‚“)
            function checkYakuRecursive(currentHand) {
                // æ‰‹ç‰Œã‚’ã‚¿ã‚¤ãƒ—é †ã«ã‚½ãƒ¼ãƒˆï¼ˆC1-1, C1-2, C1-3... SP-1ï¼‰
                currentHand.sort((a, b) => a.localeCompare(b));
                
                // çµ‚äº†æ¡ä»¶: æ‰‹ç‰ŒãŒ0æšã«ãªã£ãŸã‚‰æˆåŠŸ
                if (currentHand.length === 0) return true;
                // å¤±æ•—æ¡ä»¶: æ‰‹ç‰ŒãŒæ®‹ã£ã¦ã„ã¦ã€ãã‚ŒãŒ3ã®å€æ•°ã§ãªã‘ã‚Œã°å¤±æ•— (ã“ã‚Œã¯ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ã®ãƒ«ãƒ¼ãƒ«ã§ã¯å³å¯†ã§ã¯ãªã„ãŒã€ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯ã¨ã—ã¦)
                if (currentHand.length % 3 !== 0) return false;

                const firstTile = currentHand[0];
                const type = firstTile.substring(0, 2);
                
                // 1. åˆ»å­ï¼ˆ3æšçµ„ï¼‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
                const indices = currentHand.reduce((acc, tile, index) => {
                    if (tile === firstTile) acc.push(index);
                    return acc;
                }, []);
                
                if (indices.length >= 3) {
                    // 3æšã‚’å‰Šé™¤ã—ã¦å†å¸°
                    const nextHand = [...currentHand];
                    nextHand.splice(indices[2], 1);
                    nextHand.splice(indices[1], 1);
                    nextHand.splice(indices[0], 1);
                    if (checkYakuRecursive(nextHand)) return true;
                }
                
                // 2. é †å­ï¼ˆé€£ç•ª3æšï¼‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ (ç‰¹æ®Šç‰Œã‚’é™¤ã)
                if (type !== SPECIAL_TILE) {
                    const num = parseInt(type.substring(1));
                    const type2 = `C${num + 1}`;
                    const type3 = `C${num + 2}`;

                    // å¯¾å¿œã™ã‚‹é€£ç•ªã®ç‰ŒãŒã‚ã‚‹ã‹æ¢ã™
                    const index2 = currentHand.findIndex(t => t.startsWith(type2));
                    const index3 = currentHand.findIndex(t => t.startsWith(type3));
                    
                    if (index2 !== -1 && index3 !== -1) {
                         // 1æšãšã¤å‰Šé™¤ã—ã¦å†å¸°
                         const nextHand = [...currentHand];
                         
                         // æ¤œç´¢ã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’é€†é †ã«å‰Šé™¤ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒãšã‚Œãªã„ã‚ˆã†ã«ï¼‰
                         // å³å¯†ã«ã¯ã€å„ã‚¿ã‚¤ãƒ—ã§æœ€ã‚‚è‹¥ã„IDã‚’å‰Šé™¤ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãŒã€ã“ã“ã§ã¯ç°¡æ˜“çš„ã«æœ€åˆã«è¦‹ã¤ã‹ã£ãŸã‚‚ã®ã‚’å‰Šé™¤
                         const removeIndices = [index3, index2, 0].sort((a, b) => b - a); // é€†é †ã‚½ãƒ¼ãƒˆ
                         
                         const handToRemove = [];
                         if (nextHand[0].startsWith(type)) handToRemove.push(0);
                         if (nextHand[index2].startsWith(type2)) handToRemove.push(index2);
                         if (nextHand[index3].startsWith(type3)) handToRemove.push(index3);
                         
                         if (handToRemove.length === 3) {
                              const finalHand = [...currentHand];
                              finalHand.splice(handToRemove[2], 1);
                              finalHand.splice(handToRemove[1], 1);
                              finalHand.splice(handToRemove[0], 1);
                             if (checkYakuRecursive(finalHand)) return true;
                         }
                    }
                }
                
                // 3. ç‰¹æ®Šç‰Œï¼ˆSPï¼‰ã‚’åˆ»å­ã®ä¸€éƒ¨ã¨ã—ã¦ä½¿ã†ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆç°¡æ˜“ç‰ˆã§ã¯çœç•¥ï¼‰
                // è¤‡é›‘åŒ–ã‚’é¿ã‘ã‚‹ãŸã‚ã€ã“ã“ã§ã¯ç‰¹æ®Šç‰Œã¯å˜ç‹¬ã®åˆ»å­ï¼ˆ3æšï¼‰ã¨ã—ã¦ã®ã¿æ‰±ã†ã¨ä»®å®šã—ã¾ã™ã€‚
                
                return false;
            }
            
            // å½¹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã®ç°¡æ˜“åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯ç‰Œã®ã‚¿ã‚¤ãƒ—ã¨æšæ•°ã®ã¿ã§åˆ¤å®šã—ã¾ã™ã€‚
            function simpleYakuCheck(currentHand) {
                if (currentHand.length === 0) return true;
                if (currentHand.length % 3 !== 0) return false;

                const counts = {};
                let sp_count = 0;
                let tiles = [];
                currentHand.forEach(id => {
                    const type = id.substring(0, 2);
                    if (type === SPECIAL_TILE) {
                        sp_count++;
                    } else {
                        if (!counts[type]) {
                            counts[type] = 0;
                            tiles.push(type);
                        }
                        counts[type]++;
                    }
                });

                tiles.sort();
                
                // SPãŒ3æšçµ„ã‚’æ§‹æˆã§ãã‚‹ã‹
                if (sp_count >= 3 && simpleYakuCheck(currentHand.slice(sp_count))) return true;

                // ç‰Œã‚’å¼•ã„ã¦ã€3æšçµ„ã®æ§‹æˆã‚’è©¦ã¿ã‚‹
                
                // 1. åˆ»å­ (3æš)
                for (const type of tiles) {
                    if (counts[type] >= 3) {
                        counts[type] -= 3;
                        const nextHand = currentHand.filter(id => !id.startsWith(type) || counts[type] > 0);
                        if (simpleYakuCheck(nextHand)) return true;
                        counts[type] += 3; // backtrack
                    }
                }
                
                // 2. é †å­ (é€£ç•ª3æš C1, C2, C3)
                for (let i = 0; i <= tiles.length - 3; i++) {
                    const type1 = tiles[i];
                    const num1 = parseInt(type1.substring(1));
                    if (num1 >= 1 && num1 <= 7) {
                        const type2 = `C${num1 + 1}`;
                        const type3 = `C${num1 + 2}`;
                        
                        if (counts[type1] > 0 && counts[type2] > 0 && counts[type3] > 0) {
                             counts[type1]--;
                             counts[type2]--;
                             counts[type3]--;
                             
                             // æ¬¡ã®å†å¸°ã®ãŸã‚ã«ã€è¦ç´ æ•°ãŒ0ã«ãªã£ãŸç‰Œã¯å‰Šé™¤
                             const nextHand = currentHand.filter(id => {
                                 const type = id.substring(0, 2);
                                 return type === SPECIAL_TILE || counts[type] > 0;
                             });

                             if (simpleYakuCheck(nextHand)) return true;

                             counts[type1]++; // backtrack
                             counts[type2]++;
                             counts[type3]++;
                        }
                    }
                }

                return false;
            }

            // ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯ã¯å®Ÿè£…ãŒé›£ã—ã„ãŸã‚ã€æ‰‹ç‰Œã‚’ã‚½ãƒ¼ãƒˆã—ã€3æšçµ„ãŒ3ã¤ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™
            // å®Ÿéš›ã«ã¯ã€9æšã®æ‰‹ç‰Œã‹ã‚‰æ¨ã¦ã‚‹ç‰Œ1æšã‚’é¸ã³ã€æ®‹ã‚Šã®8æšã§å½¹ãŒæˆç«‹ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
            
            // 9æšã®æ‰‹ç‰Œã‹ã‚‰1æšãšã¤é¸ã³ã€æ®‹ã‚Šã®8æšã§å½¹åˆ¤å®š
            for (let i = 0; i < hand.length; i++) {
                const eightTiles = [...hand.slice(0, i), ...hand.slice(i + 1)];
                if (check8Tiles(eightTiles)) {
                    return true;
                }
            }
            return false;
        }

        function check8Tiles(hand) {
             // 8æšã®æ‰‹ç‰Œã§ã€ç‰¹æ®Šç‰Œã‚’å«ã‚ã¦3æšçµ„ãŒ2ã¤ã§ãã¦ã„ã‚‹ã‹ï¼ˆåˆ»å­ã¾ãŸã¯é †å­ï¼‰ã¨é›€é ­ï¼ˆ2æšçµ„ï¼‰1ã¤
             // ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ã®ä¸€èˆ¬çš„ãªãƒ«ãƒ¼ãƒ«ï¼ˆ3æšçµ„Ã—3ã€é›€é ­1ã¤ï¼‰ã«ã¯å½“ã¦ã¯ã¾ã‚‰ãªã„ãŸã‚ã€
             // ã“ã“ã§ã¯ã€Œ3æšçµ„3ã¤ã€ã¨ã„ã†ç°¡æ˜“ãƒ«ãƒ¼ãƒ«ã«åˆã‚ã›ã€8æšã§å½¹åˆ¤å®šã‚’ã™ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
             // 9æšæ™‚ã«ã—ã‹åˆ¤å®šã‚’è¡Œã‚ãªã„ãŸã‚ã€ã“ã®é–¢æ•°ã¯å¸¸ã«falseã‚’è¿”ã—ã¾ã™ã€‚
             return false;
        }


        // -----------------------------------------------------
        // 7. ãƒãƒ£ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
         */
        async function sendMessage() {
            if (!isAuthReady || !roomId || !roomRef) return;

            const messageText = chatInput.value.trim();
            if (messageText === "") return;

            const newMessage = {
                senderId: userId,
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®æœ€åˆã®4æ–‡å­—ã‚’ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¨ã—ã¦ä½¿ç”¨
                senderAlias: `User-${userId.substring(0, 4)}`, 
                text: messageText,
                timestamp: Date.now()
            };

            try {
                // Firestoreã®messagesé…åˆ—ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                await updateDoc(roomRef, {
                    messages: arrayUnion(newMessage)
                });
                chatInput.value = '';
            } catch (error) {
                console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
         */
        function renderMessages(messages) {
            messagesList.innerHTML = '';
            
            // æœ€æ–°ã®50ä»¶ã‚’è¡¨ç¤º
            const msgs = messages.slice(-50); 
            
            msgs.forEach(msg => {
                const isMe = msg.senderId === userId;
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(isMe ? 'my-message' : 'other-message');
                
                const alias = msg.senderAlias || `User-${msg.senderId.substring(0, 4)}`;
                const time = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

                messageElement.innerHTML = `
                    <div class="message-header">
                        <span class="sender">${isMe ? 'ç§' : alias}</span>
                        <span class="time">${time}</span>
                    </div>
                    <div class="message-content">${msg.text}</div>
                `;
                messagesList.appendChild(messageElement);
            });
            // ä¸€ç•ªä¸‹ã¾ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            messagesList.scrollTop = messagesList.scrollHeight;
        }

        
        /**
         * ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç† (ãƒªãƒ­ãƒ¼ãƒ‰ã§ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹)
         */
        async function endGame(winnerId) {
            drawButton.disabled = true;
            checkButton.disabled = true;
            discardSelectedButton.style.display = 'none';

            if (isHost && roomData.status !== 'finished') {
                // ãƒ›ã‚¹ãƒˆãŒstatusã‚’'finished'ã«æ›´æ–°
                await updateDoc(roomRef, { status: 'finished', winnerId: winnerId || null });
            }

            if (peerConnection) {
                 peerConnection.close();
            }
            isConnectedP2P = false;
            
            // å‹è€…è¡¨ç¤º
            if (winnerId) {
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚å‹è€…: ${winnerId === userId ? 'ã‚ãªãŸ' : 'ç›¸æ‰‹'}`;
                 connectionStatus.style.backgroundColor = winnerId === userId ? '#00FF00' : '#FF0000';
            } else {
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚`;
                 connectionStatus.style.backgroundColor = '#AAAAAA';
            }

            // 3ç§’å¾Œã«ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹
            setTimeout(() => {
                location.reload(); 
            }, 3000);
        }
        
        /**
         * ã‚·ãƒ£ãƒƒãƒ•ãƒ«é–¢æ•° (Fisher-Yates)
         */
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        
        // -----------------------------------------------------
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        // -----------------------------------------------------

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('create-room-button').addEventListener('click', createRoom);
            document.getElementById('join-room-button').addEventListener('click', () => joinRoom());
            document.getElementById('start-game-button').addEventListener('click', startGame);
            drawButton.onclick = drawTile;
            checkButton.onclick = checkHandForYaku;
            discardSelectedButton.onclick = discardSelectedTile;
            
            // ãƒãƒ£ãƒƒãƒˆé–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            sendButton.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            initFirebase();
        });

    </script>
    <style>
        :root {
            --tile-bg: #fff;
            --tile-border: #333;
            --deck-bg: #556B2F; /* Olive Drab */
            --player-bg: #f4f4f9;
            --primary-color: #e94e77; /* Pinkish Red */
            --secondary-color: #4CAF50; /* Green */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1200px; /* æ¨ªå¹…ã‚’åºƒã’ã¦ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã‚’ç¢ºä¿ */
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 700;
            letter-spacing: 2px;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
        }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (ã‚²ãƒ¼ãƒ ã¨ãƒãƒ£ãƒƒãƒˆã‚’ä¸¦ã¹ã‚‹) */
        #game-container {
            display: none;
            gap: 20px;
            flex-wrap: wrap; /* å°ã•ã„ç”»é¢ã§æŠ˜ã‚Šè¿”ã™ */
        }

        #game-content {
            flex-grow: 1;
            min-width: 450px; /* ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã®æœ€å°å¹… */
        }
        
        /* ç‰Œã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        .tile {
            width: 45px;
            height: 60px;
            background-color: var(--tile-bg);
            border: 2px solid var(--tile-border);
            border-radius: 6px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        /* ç‰Œã®è‰²ä»˜ã‘ */
        .tile[data-type^="C1"] { color: #FFD700; background-color: #FFFACD; }
        .tile[data-type^="C2"] { color: #4169E1; background-color: #F0F8FF; }
        .tile[data-type^="C3"] { color: #3CB371; background-color: #F0FFF0; }
        .tile[data-type^="C4"] { color: #FF4500; background-color: #FFF0F5; }
        .tile[data-type^="C5"] { color: #800080; background-color: #E6E6FA; }
        .tile[data-type^="C6"] { color: #A52A2A; background-color: #FAF0E6; }
        .tile[data-type^="C7"] { color: #008080; background-color: #E0FFFF; }
        .tile[data-type^="C8"] { color: #FF69B4; background-color: #FFE4E1; }
        .tile[data-type^="C9"] { color: #2F4F4F; background-color: #F5F5F5; }
        .tile[data-type^="SP"] { color: var(--primary-color); background-color: #FFFAFA; border-color: var(--primary-color); }
        .tile[data-type^="SP"]::after { content: "â˜…"; }

        /* è£è¿”ã—ã®ç‰Œï¼ˆå±±æœ­/ç›¸æ‰‹æ‰‹ç‰Œï¼‰ */
        .tile.face-down {
            background-color: var(--deck-bg);
            border-color: #333;
            color: transparent;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            cursor: default;
        }
        .tile.face-down:hover { transform: none; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); }

        /* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .board-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .discard-area, .deck-area {
            flex-basis: 48%;
            padding: 10px;
            border-radius: 8px;
            background-color: #e0e0e0;
            text-align: center;
        }

        .discard-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 70px;
            justify-content: center;
        }
        
        .deck-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            background-color: #d0e0d0;
        }

        .hand-area {
            background-color: var(--player-bg);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #ccc;
            margin-bottom: 15px;
        }

        .tile-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 70px;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #c93e64; transform: translateY(-1px); }
        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #3e8e41; transform: translateY(-1px); }
        
        .btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }
        
        /* é¸æŠä¸­ã®ç‰Œ */
        .tile.selected {
            border: 4px solid var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
            transform: translateY(-5px);
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #message-box {
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 700;
            min-height: 30px;
        }
        .message-success { background-color: #e6ffe6; color: var(--secondary-color); border: 1px solid var(--secondary-color); }
        .message-error { background-color: #ffe6e6; color: var(--primary-color); border: 1px solid var(--primary-color); }
        .message-normal { background-color: #f0f8ff; color: #444; border: 1px solid #aaa; }
        
        #connection-status {
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 10px;
            color: white;
            background-color: #ccc;
        }
        
        /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
        #lobby-container {
            text-align: center;
            display: none;
        }
        .input-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .input-group input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 150px;
        }
        #user-id-display {
             font-size: 0.8em;
             color: #666;
             margin-top: 10px;
        }
        #player-list {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
        }
        
        /* --- ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #chat-container {
            width: 300px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #f8f8f8;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        #messages-list {
            flex-grow: 1;
            height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px;
            scroll-behavior: smooth;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 10px;
            line-height: 1.4;
            max-width: 90%;
            word-wrap: break-word;
        }

        .message-header {
            font-size: 0.75em;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }
        .sender { font-weight: bold; }
        .time { color: #999; }
        .message-content { font-size: 0.9em; }

        .my-message {
            background-color: #e9f0ff; /* Light Blue */
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .other-message {
            background-color: #fff;
            border: 1px solid #eee;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        #chat-input-area {
            display: flex;
            gap: 5px;
        }

        #chat-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 800px) {
            #game-container {
                flex-direction: column;
            }
            #chat-container {
                width: 100%;
                margin-top: 20px;
                max-height: 300px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>WebRTCãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© (2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ)</h1>
    <p id="loading-message" style="text-align: center; font-weight: bold;">èªè¨¼ä¸­...</p>
    
    <!-- ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
    <div id="lobby-container">
        <div id="connection-status">åˆæœŸåŒ–ä¸­...</div>
        <div class="input-group">
            <h2 style="color: #4CAF50;">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</h2>
            <button id="create-room-button" class="btn btn-secondary">æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>
        <div class="input-group">
            <h2 style="color: #e94e77;">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </h2>
            <input type="text" id="room-id-input" placeholder="ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›" maxlength="8">
            <button id="join-room-button" class="btn btn-primary">å‚åŠ </button>
        </div>
        <p id="user-id-display"></p>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ï¼†ãƒãƒ£ãƒƒãƒˆç”»é¢ -->
    <div id="game-container">
        
        <!-- ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ -->
        <div id="game-content" style="display: none;">
            <h2 id="room-title" style="text-align: center; margin-bottom: 5px;"></h2>
            <p id="player-list" style="text-align: center;"></p>

            <div id="connection-status">æ¥ç¶šå¾…æ©Ÿä¸­...</div>
            <div id="message-box"></div>
            
            <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area" style="background-color: #e6e6e6;">
                <h2 style="margin-top: 0; color: #555;">å¯¾æˆ¦ç›¸æ‰‹ã®æ‰‹ç‰Œ</h2>
                <div id="opponent-hand-container" class="tile-list">
                    <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œï¼ˆè£è¿”ã—ï¼‰ -->
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                </div>
            </div>

            <div class="board-area">
                <!-- å±±æœ­ã‚¨ãƒªã‚¢ -->
                <div class="deck-area">
                    <p style="font-weight: 700;">å±±æœ­ (<span id="deck-count">40</span>)</p>
                    <div class="tile face-down"></div>
                </div>

                <!-- æ¨ã¦ç‰Œã‚¨ãƒªã‚¢ -->
                <div class="discard-area">
                    <p style="font-weight: 700;">æ¨ã¦ç‰Œ</p>
                    <div id="discard-container" class="discard-list">
                        <!-- æ¨ã¦ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area">
                <h2 style="margin-top: 0; color: #555;">ã‚ãªãŸã®æ‰‹ç‰Œ (<span id="hand-count">0</span>æš)</h2>
                <p id="current-turn" style="font-weight: bold; padding: 5px; border-radius: 4px; text-align: center;"></p>
                <div id="hand-container" class="tile-list">
                    <!-- ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>

            <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ -->
            <div class="controls">
                <button id="draw-button" class="btn btn-primary">å±±æœ­ã‹ã‚‰1æšå¼•ã</button>
                <button id="discard-selected-button" class="btn btn-primary" style="display: none;">é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹</button>
                <button id="check-button" class="btn btn-secondary" disabled>å½¹ã‚’åˆ¤å®šã™ã‚‹ (9æšå¿…é ˆ)</button>
                <button id="start-game-button" class="btn btn-secondary" style="display: none;">ã‚²ãƒ¼ãƒ é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿)</button>
            </div>
            <button class="btn" style="background-color: #777; color: white; margin-top: 15px;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>
        </div>
        
        <!-- ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒŠ -->
        <div id="chat-container">
            <h3 style="margin-top: 0; color: #555;">ãƒ«ãƒ¼ãƒ ãƒãƒ£ãƒƒãƒˆ</h3>
            <div id="messages-list">
                <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...">
                <button id="send-button" class="btn btn-secondary">é€ä¿¡</button>
            </div>
        </div>
    </div>

</div>

</body>
</html>
