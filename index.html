<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTCãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© - 2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebaseã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, updateDoc, arrayUnion, arrayRemove, getDoc, runTransaction, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestoreã®ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š (ãƒ‡ãƒãƒƒã‚°ç”¨)
        setLogLevel('debug');

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆCanvasç’°å¢ƒã‹ã‚‰æä¾›ã•ã‚Œã‚‹ã‚‚ã®ã‚’å–å¾—ï¼‰
        // æä¾›ã•ã‚ŒãŸFirebaseè¨­å®šã‚’ç›´æ¥ä½¿ç”¨
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBPMqx8KHacF0XiRLSRztgXiRHoGdXFpCQ",
            authDomain: "talk-to-friends-point.firebaseapp.com",
            projectId: "talk-to-friends-point",
            storageBucket: "talk-to-friends-point.firebasestorage.app",
            messagingSenderId: "1012267135320",
            appId: "1:1012267135320:web:1bb99aa6249c88bfac752d",
            measurementId: "G-RFX7NK1Q28"
        };
        
        // Canvasç’°å¢ƒå¤‰æ•°ã¨çµ±åˆ
        const firebaseConfig = FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_CONFIG.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Firebaseã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let app;
        let db;
        let auth;
        let userId = 'loading';
        let isAuthReady = false;

        // WebRTC/ã‚²ãƒ¼ãƒ é–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        const STUN_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
        let peerConnection;
        let dataChannel;
        let roomId = '';
        let roomRef = null;
        let roomData = null;
        let unsubscribeRoom = null;
        let isHost = false;
        let isConnectedP2P = false;

        // ã‚²ãƒ¼ãƒ å®šæ•°
        const TILE_TYPES = ['C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9'];
        const SPECIAL_TILE = 'SP';
        const TILES_PER_TYPE = 4;
        const HAND_SIZE_START = 8;
        
        let playerHand = [];
        let isDrawingPhase = false; // true: ç‰Œã‚’å¼•ã„ãŸç›´å¾Œ (9æšçŠ¶æ…‹), false: ç‰Œã‚’æ¨ã¦ãŸç›´å¾Œ (8æšçŠ¶æ…‹)
        let selectedTileId = null;

        // DOMè¦ç´ ã®å–å¾—
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const drawButton = document.getElementById('draw-button');
        const checkButton = document.getElementById('check-button');
        const discardSelectedButton = document.getElementById('discard-selected-button');
        const handContainer = document.getElementById('hand-container');
        const opponentHandContainer = document.getElementById('opponent-hand-container');
        const deckCountDisplay = document.getElementById('deck-count');
        const discardContainer = document.getElementById('discard-container');
        const messageBox = document.getElementById('message-box');
        const connectionStatus = document.getElementById('connection-status');
        const currentTurnDisplay = document.getElementById('current-turn');
        const userIdDisplay = document.getElementById('user-id-display');
        
        // ãƒãƒ£ãƒƒãƒˆé–¢é€£DOMè¦ç´ 
        const messagesList = document.getElementById('messages-list');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');

        // -----------------------------------------------------
        // 1. FirebaseåˆæœŸåŒ–ã¨èªè¨¼
        // -----------------------------------------------------

        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // èªè¨¼çŠ¶æ…‹ã®ç›£è¦–
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        // åŒ¿åèªè¨¼
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    userIdDisplay.textContent = `ã‚ãªãŸã®ID: ${userId}`;
                    displayMessage("èªè¨¼å®Œäº†ã€‚ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã¾ãŸã¯å‚åŠ ã—ã¦ãã ã•ã„ã€‚", 'normal');
                    document.getElementById('loading-message').style.display = 'none';
                    lobbyContainer.style.display = 'block';
                });

                // ã‚«ã‚¹ã‚¿ãƒ èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®ä½¿ç”¨
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                }

            } catch (error) {
                console.error("FirebaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("FirebaseåˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        // -----------------------------------------------------
        // 2. ãƒ«ãƒ¼ãƒ ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function getRoomCollectionRef() {
            // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³: /artifacts/{appId}/public/data/donjara_rooms
            return collection(db, 'artifacts', appId, 'public', 'data', 'donjara_rooms');
        }

        /**
         * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ–
         */
        function createInitialRoomData() {
            // å…¨ã¦ã®ç‰Œã‚’ç”Ÿæˆ
            let initialDeck = [];
            for (const type of TILE_TYPES) {
                for (let i = 1; i <= TILES_PER_TYPE; i++) {
                    initialDeck.push(`${type}-${i}`);
                }
            }
            for (let i = 1; i <= TILES_PER_TYPE; i++) {
                 initialDeck.push(`${SPECIAL_TILE}-${i}`);
            }
            shuffle(initialDeck);

            return {
                players: [],
                deck: initialDeck,
                discardedTiles: [],
                currentPlayerId: '',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                signaling: {},
                messages: [], // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ ¼ç´ç”¨
                lastUpdated: Date.now()
            };
        }

        /**
         * ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã—ã€ãƒ›ã‚¹ãƒˆã¨ã—ã¦å‚åŠ 
         */
        async function createRoom() {
            if (!isAuthReady) return;

            roomId = crypto.randomUUID().substring(0, 8);
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = true;
            isConnectedP2P = false;

            try {
                await setDoc(roomRef, createInitialRoomData());
                await joinRoom(roomId);
            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        /**
         * ãƒ«ãƒ¼ãƒ ã«å‚åŠ 
         */
        async function joinRoom(id) {
            if (!isAuthReady) return;
            roomId = id || document.getElementById('room-id-input').value.trim();
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = false; // å‚åŠ è€…ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
            isConnectedP2P = false;

            if (!roomId) {
                displayMessage("ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", 'error');
                return;
            }

            try {
                // æ—¢å­˜ã®ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
                const roomSnapshot = await getDoc(roomRef);
                if (!roomSnapshot.exists()) {
                    displayMessage(`ãƒ«ãƒ¼ãƒ ID: ${roomId} ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`, 'error');
                    return;
                }

                // å‚åŠ å‡¦ç†ã‚’ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å®Ÿè¡Œ (ç«¶åˆå›é¿)
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.status !== 'waiting' || currentRoomData.players.length >= 2) {
                        throw new Error("ã“ã®ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã‹ã€æ—¢ã«ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                    }
                    
                    const newPlayer = { userId, hand: [], isHost: currentRoomData.players.length === 0 };
                    const newPlayers = [...currentRoomData.players, newPlayer];

                    transaction.update(roomRef, {
                        players: newPlayers,
                        signaling: { ...currentRoomData.signaling, [userId]: {} } // ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æƒ…å ±ã®åˆæœŸåŒ–
                    });
                });

                // UIåˆ‡ã‚Šæ›¿ãˆ
                document.getElementById('room-title').textContent = `ãƒ«ãƒ¼ãƒ ID: ${roomId}`;
                lobbyContainer.style.display = 'none';
                gameContainer.style.display = 'flex'; // Flexboxã«å¤‰æ›´
                document.getElementById('game-content').style.display = 'block';

                // ãƒ«ãƒ¼ãƒ ã®å¤‰æ›´ã‚’ç›£è¦–é–‹å§‹
                startRoomListener();

            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ãƒ«ãƒ¼ãƒ å‚åŠ å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        /**
         * ãƒ«ãƒ¼ãƒ ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–
         */
        function startRoomListener() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            unsubscribeRoom = onSnapshot(roomRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    roomData = docSnapshot.data();
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã®æ›´æ–°
                    const playersInfo = roomData.players.map(p => 
                        `${p.userId === userId ? 'ã‚ãªãŸ (Me)' : 'å¯¾æˆ¦ç›¸æ‰‹ (Opponent)'} ${p.isHost ? '(HOST)' : ''}`
                    ).join(' / ');
                    document.getElementById('player-list').textContent = playersInfo;

                    if (roomData.players.length === 2 && roomData.status === 'waiting') {
                        // 2äººæƒã£ãŸã‚‰WebRTCæ¥ç¶šã‚’é–‹å§‹
                        if (!peerConnection) {
                             startWebRTCConnection();
                        }
                    } else if (roomData.status === 'playing' && isConnectedP2P) {
                        // ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã€P2Pæ¥ç¶šãŒç¢ºç«‹ã—ã¦ã„ã‚Œã°ã€ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’æ›´æ–°
                        updateGameStateFromDataChannel(); // DataChannelã§åŒæœŸã™ã‚‹ãŸã‚ã€Firestoreã‹ã‚‰ã¯åˆæœŸæƒ…å ±ã®ã¿
                    }
                    
                    // ã‚·ã‚°ãƒŠãƒªãƒ³ã‚°å‡¦ç† (æ¥ç¶šç¢ºç«‹ã¾ã§)
                    handleSignaling();

                    // ã‚²ãƒ¼ãƒ UIã®æ›´æ–° (ãƒ«ãƒ¼ãƒ IDè¡¨ç¤ºã€ã‚¿ãƒ¼ãƒ³è¡¨ç¤ºãªã©)
                    updateGameUI(roomData);
                    
                    // ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ›´æ–°
                    if (roomData.messages) {
                        renderMessages(roomData.messages);
                    }

                } else {
                    displayMessage("ãƒ«ãƒ¼ãƒ ã¯å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚", 'error');
                    // ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹å‡¦ç†
                    if (unsubscribeRoom) {
                        unsubscribeRoom();
                        unsubscribeRoom = null;
                    }
                }
            });
        }
        
        /**
         * ã‚²ãƒ¼ãƒ ã®é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿å®Ÿè¡Œ)
         */
        async function startGame() {
            if (!isHost || roomData.status !== 'waiting' || roomData.players.length !== 2) return;

            // åˆæœŸé…ç‰Œã¨åˆæœŸã‚¿ãƒ¼ãƒ³ã®è¨­å®š
            const players = roomData.players.map(p => ({ ...p, hand: [] }));
            let deck = [...roomData.deck];

            // 8æšé…ã‚‹
            for (let i = 0; i < HAND_SIZE_START; i++) {
                players.forEach(p => {
                    p.hand.push(deck.pop());
                });
            }

            // å…ˆæ”»ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«æ±ºå®š
            const startingPlayerId = players[Math.floor(Math.random() * 2)].userId;

            try {
                await updateDoc(roomRef, {
                    players: players,
                    deck: deck,
                    currentPlayerId: startingPlayerId,
                    status: 'playing',
                    lastUpdated: Date.now()
                });
                displayMessage("ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸï¼", 'success');
            } catch (error) {
                console.error("ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
            }
        }
        
        // -----------------------------------------------------
        // 3. WebRTCã‚·ã‚°ãƒŠãƒªãƒ³ã‚°ã¨æ¥ç¶šãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function startWebRTCConnection() {
            connectionStatus.textContent = 'æ¥ç¶šä¸­... (WebRTC/DataChannel)';
            connectionStatus.style.backgroundColor = '#FFD700'; // Gold

            peerConnection = new RTCPeerConnection({ iceServers: STUN_SERVERS });
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    // ICEå€™è£œã‚’Firestoreã«ä¿å­˜
                    saveIceCandidate(event.candidate.toJSON());
                }
            };
            
            peerConnection.onconnectionstatechange = () => {
                console.log('RTC connection state:', peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    handleP2PConnected();
                } else if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                     // æ¥ç¶šå¤±æ•—æ™‚ã®å†è©¦è¡Œãƒ­ã‚¸ãƒƒã‚¯ (çœç•¥)
                }
            };

            // ãƒ›ã‚¹ãƒˆã¯DataChannelã‚’ä½œæˆ
            if (isHost) {
                dataChannel = peerConnection.createDataChannel("gameChannel");
                setupDataChannelListeners(dataChannel);
                createOffer();
            } else {
                // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯DataChannelã‚’å—ã‘å…¥ã‚Œã‚‹
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelListeners(dataChannel);
                };
            }
        }

        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                // Offerã‚’Firestoreã«ä¿å­˜
                await updateDoc(roomRef, {
                    [`signaling.${userId}.offer`]: peerConnection.localDescription.toJSON()
                });
            } catch (e) { console.error('Create Offer Error:', e); }
        }

        async function createAnswer(offer) {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                // Answerã‚’Firestoreã«ä¿å­˜
                await updateDoc(roomRef, {
                    [`signaling.${userId}.answer`]: peerConnection.localDescription.toJSON()
                });
            } catch (e) { console.error('Create Answer Error:', e); }
        }

        async function saveIceCandidate(candidate) {
            try {
                await updateDoc(roomRef, {
                    [`signaling.${userId}.iceCandidates`]: arrayUnion(candidate)
                });
            } catch (e) { console.error('Save ICE Candidate Error:', e); }
        }

        /**
         * Firestoreã‚·ã‚°ãƒŠãƒªãƒ³ã‚°æƒ…å ±ã®å‡¦ç†
         */
        function handleSignaling() {
            if (isConnectedP2P) return;

            const opponent = roomData.players.find(p => p.userId !== userId);
            if (!opponent || !roomData.signaling || !roomData.signaling[opponent.userId]) return;

            const opponentSignal = roomData.signaling[opponent.userId];
            const mySignal = roomData.signaling[userId];
            
            // 1. Offerã®å‡¦ç† (ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´)
            if (!isHost && opponentSignal.offer && !mySignal.answer) {
                console.log('Received Offer, creating Answer...');
                createAnswer(opponentSignal.offer);
            }

            // 2. Answerã®å‡¦ç† (ãƒ›ã‚¹ãƒˆå´)
            if (isHost && opponentSignal.answer && !peerConnection.remoteDescription) {
                console.log('Received Answer, setting Remote Description...');
                peerConnection.setRemoteDescription(new RTCSessionDescription(opponentSignal.answer));
            }
            
            // 3. ICEå€™è£œã®å‡¦ç†
            if (opponentSignal.iceCandidates && opponentSignal.iceCandidates.length > 0) {
                opponentSignal.iceCandidates.forEach(candidate => {
                    const ice = new RTCIceCandidate(candidate);
                    peerConnection.addIceCandidate(ice).catch(e => console.error('Error adding received ICE candidate:', e));
                });
                // å‡¦ç†ã—ãŸICEå€™è£œã‚’Firestoreã‹ã‚‰å‰Šé™¤ (ãƒ‡ãƒ¼ã‚¿å‰Šæ¸›ã®ãŸã‚)
                updateDoc(roomRef, {
                    [`signaling.${opponent.userId}.iceCandidates`]: []
                });
            }
        }
        
        /**
         * P2Pæ¥ç¶šå®Œäº†æ™‚ã®å‡¦ç†
         */
        function handleP2PConnected() {
            isConnectedP2P = true;
            connectionStatus.textContent = 'æ¥ç¶šå®Œäº† (DataChannel)';
            connectionStatus.style.backgroundColor = '#4CAF50'; // Green

            // 2äººæƒã£ã¦ã„ã‚Œã°ãƒ›ã‚¹ãƒˆãŒã‚²ãƒ¼ãƒ é–‹å§‹
            if (isHost && roomData.players.length === 2 && roomData.status === 'waiting') {
                startGame();
            }
        }
        
        // -----------------------------------------------------
        // 4. DataChannelé€šä¿¡ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function setupDataChannelListeners(channel) {
            channel.onopen = () => {
                console.log("Data Channel Opened");
            };
            
            channel.onclose = () => {
                console.log("Data Channel Closed");
                isConnectedP2P = false;
                connectionStatus.textContent = 'åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ';
                connectionStatus.style.backgroundColor = '#FF4500'; // OrangeRed
            };
            
            channel.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleDataChannelMessage(message);
            };
        }
        
        /**
         * P2PçµŒç”±ã§ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡
         */
        function sendGameAction(actionType, payload = {}) {
            if (isConnectedP2P && dataChannel.readyState === 'open') {
                const message = {
                    type: actionType,
                    senderId: userId,
                    payload
                };
                dataChannel.send(JSON.stringify(message));
            } else {
                // P2Pæœªæ¥ç¶šæ™‚ã¯FirestoreçµŒç”±ã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è©¦ã¿ã‚‹ï¼ˆç°¡æ˜“ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
                console.warn("P2Pæ¥ç¶šãªã—ã€‚ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å®Ÿè¡Œã«å¤±æ•—ã€ã¾ãŸã¯FirestoreåŒæœŸå¾…ã¡ã€‚");
            }
        }
        
        /**
         * P2PçµŒç”±ã§å—ã‘å–ã£ãŸã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿å‡¦ç†
         */
        function handleDataChannelMessage(message) {
            if (message.senderId === userId) return; // è‡ªåˆ†ãŒé€ã£ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–
            
            switch (message.type) {
                case 'GAME_STATE_SYNC':
                    // ã‚²ãƒ¼ãƒ çŠ¶æ…‹å…¨ä½“ã‚’åŒæœŸ
                    updateGameState(message.payload);
                    break;
                case 'DRAW_TILE':
                    // ç›¸æ‰‹ãŒç‰Œã‚’å¼•ã„ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    opponentDrawTile(message.payload.tileId, message.payload.newDeck);
                    break;
                case 'DISCARD_TILE':
                    // ç›¸æ‰‹ãŒç‰Œã‚’æ¨ã¦ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    opponentDiscardTile(message.payload.tileId, message.payload.newHand, message.payload.nextPlayerId);
                    break;
                case 'YAKU_CHECK':
                    // ç›¸æ‰‹ãŒå½¹åˆ¤å®šã‚’ã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³
                    displayMessage(`å¯¾æˆ¦ç›¸æ‰‹ãŒå½¹ã®åˆ¤å®šã‚’ã—ã¾ã—ãŸ: ${message.payload.isYaku ? 'æˆç«‹ï¼ã‚²ãƒ¼ãƒ çµ‚äº†' : 'ä¸æˆç«‹'}`, message.payload.isYaku ? 'success' : 'error');
                    if (message.payload.isYaku) {
                        endGame(message.payload.winnerId);
                    }
                    break;
                default:
                    console.warn("Unknown message type:", message.type);
            }
        }
        
        // -----------------------------------------------------
        // 5. ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ (WebRTCåŒæœŸå¯¾å¿œ)
        // -----------------------------------------------------

        /**
         * åˆæœŸã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åŒæœŸ (ãƒ›ã‚¹ãƒˆã‹ã‚‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸)
         */
        function updateGameState(newState) {
             roomData = newState;
             
             // è‡ªåˆ†ã®æ‰‹ç‰Œã‚’è¨­å®š
             const myState = roomData.players.find(p => p.userId === userId);
             playerHand = myState ? myState.hand : [];
             isDrawingPhase = playerHand.length > HAND_SIZE_START;

             updateUI();
             updateGameUI(roomData);
        }

        /**
         * UIã®æ›´æ–° (ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã«ä¾å­˜)
         */
        function updateGameUI(data) {
            if (!data || data.status !== 'playing') {
                currentTurnDisplay.textContent = 'ã‚²ãƒ¼ãƒ å¾…ã¡';
                currentTurnDisplay.style.backgroundColor = '#ccc';
                drawButton.disabled = true;
                checkButton.disabled = true;
                discardSelectedButton.style.display = 'none';
                return;
            }

            const myTurn = data.currentPlayerId === userId;
            const myPlayerState = data.players.find(p => p.userId === userId);
            const opponentPlayerState = data.players.find(p => p.userId !== userId);
            
            // ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
            currentTurnDisplay.textContent = myTurn ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
            currentTurnDisplay.style.backgroundColor = myTurn ? '#aaffaa' : '#ffaaaa';
            
            // ãƒœã‚¿ãƒ³åˆ¶å¾¡
            drawButton.disabled = !myTurn || isDrawingPhase || data.deck.length === 0;
            checkButton.disabled = !myTurn || playerHand.length !== 9;
            discardSelectedButton.style.display = (myTurn && isDrawingPhase && selectedTileId) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTileId;
            
            // å±±æœ­ã¨æ¨ã¦ç‰Œ
            deckCountDisplay.textContent = data.deck.length;
            renderDiscardedTiles(data.discardedTiles);

            // ç›¸æ‰‹ã®æ‰‹ç‰Œ (è£è¿”ã—)
            opponentHandContainer.innerHTML = '';
            if (opponentPlayerState) {
                // ç›¸æ‰‹ã®æ‰‹ç‰Œã®æšæ•°ã ã‘è£è¿”ã—ã®ç‰Œã‚’è¡¨ç¤º
                for (let i = 0; i < opponentPlayerState.hand.length; i++) {
                    // P2Pé€šä¿¡ãŒç¢ºç«‹ã—ã¦ã„ã‚Œã°ã€ç›¸æ‰‹ã®æ‰‹ç‰Œã¯Firestoreã«ã¯å…¥ã£ã¦ã„ãªã„ï¼ˆç©ºé…åˆ—ï¼‰
                    // ã—ãŸãŒã£ã¦ã€ã“ã®hand.lengthã¯P2Pã§åŒæœŸã•ã‚ŒãŸãƒ­ãƒ¼ã‚«ãƒ«ã®çŠ¶æ…‹ã«åŸºã¥ãå¿…è¦ãŒã‚ã‚‹
                    // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«Firestoreã®playersé…åˆ—ã®hand.lengthã‚’ä½¿ã† (P2PåŒæœŸãŒå¤±æ•—ã—ãŸå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯)
                    opponentHandContainer.appendChild(Object.assign(document.createElement('div'), { className: 'tile face-down' }));
                }
            }

            // ãƒ›ã‚¹ãƒˆã¯ã‚²ãƒ¼ãƒ é–‹å§‹ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
            if (isHost && data.players.length === 2 && data.status === 'waiting') {
                document.getElementById('start-game-button').style.display = 'block';
            } else {
                 document.getElementById('start-game-button').style.display = 'none';
            }
        }

        /**
         * ç‰ŒDOMè¦ç´ ã®ç”Ÿæˆ
         */
        function createTileElement(tileId, selectable = true) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.setAttribute('data-id', tileId);
            tile.setAttribute('data-type', tileId.substring(0, 2));
            tile.textContent = tileId.substring(1, 2) === 'P' ? 'â˜…' : tileId.substring(1, 2);

            if (selectable) {
                tile.addEventListener('click', handleTileClick);
            }
            return tile;
        }
        
        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
         */
        function displayMessage(text, type = 'normal') {
            messageBox.textContent = text;
            messageBox.className = '';
            messageBox.classList.add('message-box');
            if (type === 'success') {
                messageBox.classList.add('message-success');
            } else if (type === 'error') {
                messageBox.classList.add('message-error');
            } else {
                 messageBox.classList.add('message-normal');
            }
        }

        /**
         * æ‰‹ç‰ŒUIã‚’æ›´æ–°
         */
        function updateUI() {
            // æ‰‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            handContainer.innerHTML = '';
            playerHand.sort((a, b) => a.localeCompare(b));
            playerHand.forEach(tileId => {
                const tileEl = createTileElement(tileId);
                if (tileId === selectedTileId) {
                     tileEl.classList.add('selected');
                }
                handContainer.appendChild(tileEl);
            });
            
            // é¸æŠçŠ¶æ…‹ã®æ›´æ–°ã«å¿œã˜ã¦æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã‚’åˆ¶å¾¡
            const selectedTile = handContainer.querySelector('.tile.selected');
            discardSelectedButton.style.display = (roomData && roomData.currentPlayerId === userId && isDrawingPhase && selectedTile) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTile;
            
            document.getElementById('hand-count').textContent = playerHand.length;
        }
        
        /**
         * æ¨ã¦ç‰Œã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
         */
        function renderDiscardedTiles(tiles) {
            discardContainer.innerHTML = '';
            // æœ€æ–°ã®15æšã‚’è¡¨ç¤º
            tiles.slice(-15).forEach(tileId => {
                 discardContainer.appendChild(createTileElement(tileId, false));
            });
        }

        /**
         * ç‰Œã®ã‚¯ãƒªãƒƒã‚¯å‡¦ç† (é¸æŠ)
         */
        function handleTileClick(event) {
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase) {
                displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã€ç‰Œã‚’å¼•ã„ãŸå¾Œã§ã®ã¿æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã§ãã¾ã™ã€‚", 'error');
                return;
            }

            const tileElement = event.currentTarget;
            const tileId = tileElement.getAttribute('data-id');

            const isSelected = tileElement.classList.contains('selected');
            
            // å…¨ã¦ãƒªã‚»ãƒƒãƒˆ
            handContainer.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            selectedTileId = null;

            if (!isSelected) {
                // æ–°ã—ãé¸æŠ
                tileElement.classList.add('selected');
                selectedTileId = tileId;
                displayMessage(`${tileId.substring(0, 2)}ã®ç‰Œã‚’é¸æŠã—ã¾ã—ãŸã€‚ã“ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€å½¹åˆ¤å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚`);
            } else {
                displayMessage("æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
            }
            updateGameUI(roomData); // æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºæ›´æ–°
        }

        // -----------------------------------------------------
        // 6. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
        // -----------------------------------------------------
        
        /**
         * å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã
         */
        async function drawTile() {
            if (!roomData || roomData.currentPlayerId !== userId || isDrawingPhase || roomData.deck.length === 0) return;
            
            // ãƒ›ã‚¹ãƒˆã¯Firestoreã§ç›´æ¥æ“ä½œã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸åŒæœŸ
            if (isHost) {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId || currentRoomData.deck.length === 0) return;

                    const drawnTile = currentRoomData.deck.pop();
                    const newDeck = currentRoomData.deck;
                    
                    const myPlayerIndex = currentRoomData.players.findIndex(p => p.userId === userId);
                    currentRoomData.players[myPlayerIndex].hand.push(drawnTile);

                    transaction.update(roomRef, {
                        deck: newDeck,
                        players: currentRoomData.players,
                        lastUpdated: Date.now()
                    });
                    
                    // P2Pã§ç›¸æ‰‹ã«ã‚‚é€šçŸ¥ (æˆåŠŸã—ãŸå ´åˆã®ã¿)
                    sendGameAction('DRAW_TILE', { tileId: drawnTile, newDeck: newDeck });
                });
            } else {
                // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¯ã€ãƒ›ã‚¹ãƒˆã‹ã‚‰ã®Firestoreæ›´æ–°ã‚’å¾…ã¤
                displayMessage("ãƒ›ã‚¹ãƒˆã‹ã‚‰ã®åŒæœŸã‚’å¾…ã£ã¦ã„ã¾ã™...", 'normal');
            }

            // ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–° (ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå‰ã«ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’å…ˆè¡Œæ›´æ–°ã™ã‚‹ã®ã¯å±é™ºã ãŒã€ã“ã“ã§ã¯ç°¡æ˜“çš„ã«è¡Œã†)
            isDrawingPhase = true;
            updateUI();
            updateGameUI(roomData);
            displayMessage("å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ãã¾ã—ãŸã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", 'success');
        }

        /**
         * ç›¸æ‰‹ãŒç‰Œã‚’å¼•ã„ãŸæ™‚ã®å‡¦ç†
         */
        function opponentDrawTile(tileId, newDeck) {
            const opponent = roomData.players.find(p => p.userId !== userId);
            if (opponent) {
                // ç›¸æ‰‹ã®æ‰‹æœ­ã¯è¦‹ãŸç›®ä¸Šå¢—ãˆã‚‹ãŒã€ä¸­èº«ã¯åˆ†ã‹ã‚‰ãªã„
                opponent.hand.push('???'); 
            }
            // roomData.deck = newDeck; // Firestoreã®ãƒªã‚¹ãƒŠãƒ¼ãŒæ›´æ–°ã™ã‚‹ã®ã§ä¸è¦ã ãŒã€P2PåŒæœŸãŒã‚ã‚Œã°å¿…è¦
            // roomData.currentPlayerId = opponent.userId; // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã«
            updateGameUI(roomData);
            displayMessage("å¯¾æˆ¦ç›¸æ‰‹ãŒç‰Œã‚’å¼•ãã¾ã—ãŸã€‚");
        }

        /**
         * é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹
         */
        async function discardSelectedTile() {
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase || !selectedTileId) return;

            const tileIdToDiscard = selectedTileId;
            const tileIndex = playerHand.indexOf(tileIdToDiscard);
            if (tileIndex === -1) return;

            // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’æ±ºå®š
            const opponentId = roomData.players.find(p => p.userId !== userId).userId;
            const nextPlayerId = opponentId;

            // ãƒ›ã‚¹ãƒˆã¯Firestoreã§ç›´æ¥æ“ä½œã—ã€ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã¸åŒæœŸ
            if (isHost) {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId) return;

                    const myPlayerIndex = currentRoomData.players.findIndex(p => p.userId === userId);
                    // Firestoreã®é…åˆ—ã‹ã‚‰å‰Šé™¤
                    currentRoomData.players[myPlayerIndex].hand.splice(tileIndex, 1);
                    currentRoomData.discardedTiles.push(tileIdToDiscard);

                    transaction.update(roomRef, {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        currentPlayerId: nextPlayerId,
                        lastUpdated: Date.now()
                    });
                    
                    // P2Pã§ç›¸æ‰‹ã«ã‚‚é€šçŸ¥
                    sendGameAction('DISCARD_TILE', { 
                        tileId: tileIdToDiscard, 
                        newHand: currentRoomData.players[myPlayerIndex].hand,
                        nextPlayerId: nextPlayerId
                    });
                });
            } else {
                 displayMessage("ãƒ›ã‚¹ãƒˆã‹ã‚‰ã®åŒæœŸã‚’å¾…ã£ã¦ã„ã¾ã™...", 'normal');
            }
            
            // ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–°
            playerHand.splice(tileIndex, 1);
            roomData.discardedTiles.push(tileIdToDiscard);
            roomData.currentPlayerId = nextPlayerId;
            
            isDrawingPhase = false;
            selectedTileId = null;
            updateUI();
            updateGameUI(roomData);
            displayMessage("ç‰Œã‚’æ¨ã¦ã¾ã—ãŸã€‚ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚");
        }
        
        /**
         * ç›¸æ‰‹ãŒç‰Œã‚’æ¨ã¦ãŸæ™‚ã®å‡¦ç†
         */
        function opponentDiscardTile(tileId, opponentNewHand, nextPlayerId) {
            roomData.discardedTiles.push(tileId);
            // roomData.currentPlayerId = nextPlayerId; // Firestoreã®ãƒªã‚¹ãƒŠãƒ¼ãŒæ›´æ–°ã™ã‚‹ã®ã§ä¸è¦
            
            // ç›¸æ‰‹ã®æ‰‹ç‰Œã‚’1æšæ¸›ã‚‰ã™ (ãƒ€ãƒŸãƒ¼)
            const opponent = roomData.players.find(p => p.userId !== userId);
            if (opponent) {
                opponent.hand.pop(); 
            }

            updateGameUI(roomData);
            displayMessage(`å¯¾æˆ¦ç›¸æ‰‹ãŒ${tileId.substring(0, 2)}ã®ç‰Œã‚’æ¨ã¦ã¾ã—ãŸã€‚ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚`, 'success');
        }

        /**
         * å½¹ã®åˆ¤å®šã‚’å®Ÿè¡Œ
         */
        async function checkHandForYaku() {
            if (!roomData || roomData.currentPlayerId !== userId || playerHand.length !== 9) return;

            const isYaku = checkYaku(playerHand);

            // P2Pã§ç›¸æ‰‹ã«é€šçŸ¥
            sendGameAction('YAKU_CHECK', { isYaku: isYaku, winnerId: isYaku ? userId : null });

            if (isYaku) {
                displayMessage("ğŸ‰ å½¹ãŒæˆç«‹ã—ã¾ã—ãŸï¼(3æšçµ„3ã¤) ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰", 'success');
                endGame(userId);
            } else {
                displayMessage("å½¹ã¯æˆç«‹ã—ã¦ã„ã¾ã›ã‚“ã€‚åˆ¥ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€è«¦ã‚ã¦ãã ã•ã„ã€‚", 'error');
            }
        }
        
        /**
         * å½¹ã®åˆ¤å®š (3æšçµ„3ã¤ - ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯)
         */
        function checkYaku(hand) {
            // NOTE: ãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ã®å½¹åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã¯éå¸¸ã«è¤‡é›‘ãªãŸã‚ã€ã“ã“ã§ã¯ç°¡æ˜“çš„ãªãƒ­ã‚¸ãƒƒã‚¯ã®ã¿ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚
            // 9æšã®æ‰‹ç‰Œã§ã€ç‰¹æ®Šç‰Œã‚’å«ã‚ã¦3æšçµ„ãŒ3ã¤ã§ãã¦ã„ã‚‹ã‹ï¼ˆåˆ»å­ã¾ãŸã¯é †å­ï¼‰ã‚’åˆ¤å®šã—ã¾ã™ã€‚
            
            if (hand.length !== 9) return false;
            
            // ç‰Œã®ã‚¿ã‚¤ãƒ—ã¨æ˜Ÿã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            const tileMap = {};
            let spCount = 0;
            
            hand.forEach(id => {
                const type = id.substring(0, 2);
                if (type === SPECIAL_TILE) {
                    spCount++;
                } else {
                    tileMap[type] = (tileMap[type] || 0) + 1;
                }
            });
            
            let tiles = Object.entries(tileMap).sort((a, b) => a[0].localeCompare(b[0]));
            
            // 3æšçµ„ã‚’è²ªæ¬²æ³•ã§æ¢ã™ (éå¸¸ã«ç°¡æ˜“çš„ãªåˆ¤å®šã§ã‚ã‚Šã€å®Œå…¨ãªãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ãƒ­ã‚¸ãƒƒã‚¯ã§ã¯ã‚ã‚Šã¾ã›ã‚“)
            function canWin(currentTiles, currentSP) {
                if (currentTiles.length === 0) {
                    return currentSP >= 0 && currentSP % 3 === 0; // æ®‹ã‚Šã®SPãŒ3æšçµ„ã«ãªã‚Œã°OK
                }
                if (currentTiles.length % 3 !== 0) return false;

                const nextTiles = [...currentTiles];
                const [type, count] = nextTiles.shift();
                
                // åˆ»å­ (3æš)
                if (count >= 3) {
                    const remainingTiles = nextTiles.map(([t, c]) => t === type ? [t, c - 3] : [t, c]).filter(([t, c]) => c > 0);
                    if (canWin(remainingTiles, currentSP)) return true;
                }
                // åˆ»å­ + SP (2æš + SP 1æš)
                if (count >= 2 && currentSP >= 1) {
                    const remainingTiles = nextTiles.map(([t, c]) => t === type ? [t, c - 2] : [t, c]).filter(([t, c]) => c > 0);
                    if (canWin(remainingTiles, currentSP - 1)) return true;
                }

                // é †å­ (é€£ç•ª3æš C1, C2, C3)
                const num = parseInt(type.substring(1));
                if (num > 0 && num <= 7) {
                    const type2 = `C${num + 1}`;
                    const type3 = `C${num + 2}`;
                    const index2 = nextTiles.findIndex(([t]) => t === type2);
                    const index3 = nextTiles.findIndex(([t]) => t === type3);

                    if (count >= 1 && index2 !== -1 && nextTiles[index2][1] >= 1 && index3 !== -1 && nextTiles[index3][1] >= 1) {
                        // C1, C2, C3 ã®é †å­
                        const nextCounts = nextTiles.map(([t, c]) => {
                            if (t === type2) return [t, c - 1];
                            if (t === type3) return [t, c - 1];
                            return [t, c];
                        }).filter(([t, c]) => c > 0);
                        if (canWin(nextCounts, currentSP)) return true;
                    }
                }
                
                // (SPã‚’ä½¿ã£ãŸé †å­ãƒ»åˆ»å­ã®ãƒ­ã‚¸ãƒƒã‚¯ã¯çœç•¥)

                return false;
            }

            return canWin(tiles, spCount);
        }
        
        /**
         * ã‚²ãƒ¼ãƒ çµ‚äº†å‡¦ç†
         */
        async function endGame(winnerId) {
            drawButton.disabled = true;
            checkButton.disabled = true;
            discardSelectedButton.style.display = 'none';

            if (isHost) {
                await updateDoc(roomRef, { status: 'finished' });
            }

            if (peerConnection) {
                 peerConnection.close();
            }
            isConnectedP2P = false;
            connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚å‹è€…: ${winnerId === userId ? 'ã‚ãªãŸ' : winnerId}`;
            connectionStatus.style.backgroundColor = winnerId === userId ? '#00FF00' : '#FF0000';
            
            // 3ç§’å¾Œã«ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹
            setTimeout(() => {
                location.reload(); 
            }, 3000);
        }

        /**
         * ã‚·ãƒ£ãƒƒãƒ•ãƒ«é–¢æ•° (Fisher-Yates)
         */
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        // -----------------------------------------------------
        // 7. ãƒãƒ£ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
         */
        async function sendMessage() {
            if (!isAuthReady || !roomId || !roomRef) return;

            const messageText = chatInput.value.trim();
            if (messageText === "") return;

            const newMessage = {
                senderId: userId,
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã®æœ€åˆã®4æ–‡å­—ã‚’ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã¨ã—ã¦ä½¿ç”¨
                senderAlias: `User-${userId.substring(0, 4)}`, 
                text: messageText,
                timestamp: Date.now()
            };

            try {
                // Firestoreã®messagesé…åˆ—ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¿½åŠ 
                await updateDoc(roomRef, {
                    messages: arrayUnion(newMessage)
                });
                chatInput.value = '';
            } catch (error) {
                console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        /**
         * ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
         */
        function renderMessages(messages) {
            messagesList.innerHTML = '';
            
            // æœ€æ–°ã®50ä»¶ã‚’è¡¨ç¤º
            const msgs = messages.slice(-50); 
            
            msgs.forEach(msg => {
                const isMe = msg.senderId === userId;
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(isMe ? 'my-message' : 'other-message');
                
                const alias = msg.senderAlias || `User-${msg.senderId.substring(0, 4)}`;
                const time = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

                messageElement.innerHTML = `
                    <div class="message-header">
                        <span class="sender">${isMe ? 'ç§' : alias}</span>
                        <span class="time">${time}</span>
                    </div>
                    <div class="message-content">${msg.text}</div>
                `;
                messagesList.appendChild(messageElement);
            });
            // ä¸€ç•ªä¸‹ã¾ã§ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
            messagesList.scrollTop = messagesList.scrollHeight;
        }

        
        // -----------------------------------------------------
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        // -----------------------------------------------------

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('create-room-button').addEventListener('click', createRoom);
            document.getElementById('join-room-button').addEventListener('click', () => joinRoom());
            document.getElementById('start-game-button').addEventListener('click', startGame);
            drawButton.onclick = drawTile;
            checkButton.onclick = checkHandForYaku;
            discardSelectedButton.onclick = discardSelectedTile;
            
            // ãƒãƒ£ãƒƒãƒˆé–¢é€£ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            sendButton.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            initFirebase();
        });

    </script>
    <style>
        :root {
            --tile-bg: #fff;
            --tile-border: #333;
            --deck-bg: #556B2F; /* Olive Drab */
            --player-bg: #f4f4f9;
            --primary-color: #e94e77; /* Pinkish Red */
            --secondary-color: #4CAF50; /* Green */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1200px; /* æ¨ªå¹…ã‚’åºƒã’ã¦ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã‚’ç¢ºä¿ */
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 700;
            letter-spacing: 2px;
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
        }

        /* ã‚²ãƒ¼ãƒ ç”»é¢ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (ã‚²ãƒ¼ãƒ ã¨ãƒãƒ£ãƒƒãƒˆã‚’ä¸¦ã¹ã‚‹) */
        #game-container {
            display: none;
            gap: 20px;
            flex-wrap: wrap; /* å°ã•ã„ç”»é¢ã§æŠ˜ã‚Šè¿”ã™ */
        }

        #game-content {
            flex-grow: 1;
            min-width: 450px; /* ã‚²ãƒ¼ãƒ ã‚¨ãƒªã‚¢ã®æœ€å°å¹… */
        }
        
        /* ç‰Œã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        .tile {
            width: 45px;
            height: 60px;
            background-color: var(--tile-bg);
            border: 2px solid var(--tile-border);
            border-radius: 6px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        /* ç‰Œã®è‰²ä»˜ã‘ */
        .tile[data-type^="C1"] { color: #FFD700; background-color: #FFFACD; }
        .tile[data-type^="C2"] { color: #4169E1; background-color: #F0F8FF; }
        .tile[data-type^="C3"] { color: #3CB371; background-color: #F0FFF0; }
        .tile[data-type^="C4"] { color: #FF4500; background-color: #FFF0F5; }
        .tile[data-type^="C5"] { color: #800080; background-color: #E6E6FA; }
        .tile[data-type^="C6"] { color: #A52A2A; background-color: #FAF0E6; }
        .tile[data-type^="C7"] { color: #008080; background-color: #E0FFFF; }
        .tile[data-type^="C8"] { color: #FF69B4; background-color: #FFE4E1; }
        .tile[data-type^="C9"] { color: #2F4F4F; background-color: #F5F5F5; }
        .tile[data-type^="SP"] { color: var(--primary-color); background-color: #FFFAFA; border-color: var(--primary-color); }
        .tile[data-type^="SP"]::after { content: "â˜…"; }

        /* è£è¿”ã—ã®ç‰Œï¼ˆå±±æœ­/ç›¸æ‰‹æ‰‹ç‰Œï¼‰ */
        .tile.face-down {
            background-color: var(--deck-bg);
            border-color: #333;
            color: transparent;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            cursor: default;
        }
        .tile.face-down:hover { transform: none; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); }

        /* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .board-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .discard-area, .deck-area {
            flex-basis: 48%;
            padding: 10px;
            border-radius: 8px;
            background-color: #e0e0e0;
            text-align: center;
        }

        .discard-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 70px;
            justify-content: center;
        }
        
        .deck-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            background-color: #d0e0d0;
        }

        .hand-area {
            background-color: var(--player-bg);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #ccc;
            margin-bottom: 15px;
        }

        .tile-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 70px;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #c93e64; transform: translateY(-1px); }
        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #3e8e41; transform: translateY(-1px); }
        
        .btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }
        
        /* é¸æŠä¸­ã®ç‰Œ */
        .tile.selected {
            border: 4px solid var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
            transform: translateY(-5px);
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #message-box {
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 700;
            min-height: 30px;
        }
        .message-success { background-color: #e6ffe6; color: var(--secondary-color); border: 1px solid var(--secondary-color); }
        .message-error { background-color: #ffe6e6; color: var(--primary-color); border: 1px solid var(--primary-color); }
        .message-normal { background-color: #f0f8ff; color: #444; border: 1px solid #aaa; }
        
        #connection-status {
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 10px;
            color: white;
            background-color: #ccc;
        }
        
        /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
        #lobby-container {
            text-align: center;
            display: none;
        }
        .input-group {
            margin-bottom: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .input-group input {
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 10px;
            width: 150px;
        }
        #user-id-display {
             font-size: 0.8em;
             color: #666;
             margin-top: 10px;
        }
        #player-list {
            margin-top: 10px;
            font-weight: bold;
            color: #555;
        }
        
        /* --- ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #chat-container {
            width: 300px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #f8f8f8;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        #messages-list {
            flex-grow: 1;
            height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px;
            scroll-behavior: smooth;
        }

        .chat-message {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 10px;
            line-height: 1.4;
            max-width: 90%;
            word-wrap: break-word;
        }

        .message-header {
            font-size: 0.75em;
            margin-bottom: 2px;
            display: flex;
            justify-content: space-between;
        }
        .sender { font-weight: bold; }
        .time { color: #999; }
        .message-content { font-size: 0.9em; }

        .my-message {
            background-color: #e9f0ff; /* Light Blue */
            margin-left: auto;
            border-bottom-right-radius: 2px;
        }

        .other-message {
            background-color: #fff;
            border: 1px solid #eee;
            margin-right: auto;
            border-bottom-left-radius: 2px;
        }

        #chat-input-area {
            display: flex;
            gap: 5px;
        }

        #chat-input {
            flex-grow: 1;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 800px) {
            #game-container {
                flex-direction: column;
            }
            #chat-container {
                width: 100%;
                margin-top: 20px;
                max-height: 300px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>WebRTCãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© (2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ)</h1>
    <p id="loading-message" style="text-align: center; font-weight: bold;">èªè¨¼ä¸­...</p>
    
    <!-- ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
    <div id="lobby-container">
        <div id="connection-status">åˆæœŸåŒ–ä¸­...</div>
        <div class="input-group">
            <h2 style="color: #4CAF50;">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</h2>
            <button id="create-room-button" class="btn btn-secondary">æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>
        <div class="input-group">
            <h2 style="color: #e94e77;">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </h2>
            <input type="text" id="room-id-input" placeholder="ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›" maxlength="8">
            <button id="join-room-button" class="btn btn-primary">å‚åŠ </button>
        </div>
        <p id="user-id-display"></p>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ï¼†ãƒãƒ£ãƒƒãƒˆç”»é¢ -->
    <div id="game-container">
        
        <!-- ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ -->
        <div id="game-content" style="display: none;">
            <h2 id="room-title" style="text-align: center; margin-bottom: 5px;"></h2>
            <p id="player-list" style="text-align: center;"></p>

            <div id="connection-status">æ¥ç¶šå¾…æ©Ÿä¸­...</div>
            <div id="message-box"></div>
            
            <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area" style="background-color: #e6e6e6;">
                <h2 style="margin-top: 0; color: #555;">å¯¾æˆ¦ç›¸æ‰‹ã®æ‰‹ç‰Œ</h2>
                <div id="opponent-hand-container" class="tile-list">
                    <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œï¼ˆè£è¿”ã—ï¼‰ -->
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                    <div class="tile face-down"></div>
                </div>
            </div>

            <div class="board-area">
                <!-- å±±æœ­ã‚¨ãƒªã‚¢ -->
                <div class="deck-area">
                    <p style="font-weight: 700;">å±±æœ­ (<span id="deck-count">40</span>)</p>
                    <div class="tile face-down"></div>
                </div>

                <!-- æ¨ã¦ç‰Œã‚¨ãƒªã‚¢ -->
                <div class="discard-area">
                    <p style="font-weight: 700;">æ¨ã¦ç‰Œ</p>
                    <div id="discard-container" class="discard-list">
                        <!-- æ¨ã¦ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area">
                <h2 style="margin-top: 0; color: #555;">ã‚ãªãŸã®æ‰‹ç‰Œ (<span id="hand-count">0</span>æš)</h2>
                <p id="current-turn" style="font-weight: bold; padding: 5px; border-radius: 4px; text-align: center;"></p>
                <div id="hand-container" class="tile-list">
                    <!-- ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>

            <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ -->
            <div class="controls">
                <button id="draw-button" class="btn btn-primary">å±±æœ­ã‹ã‚‰1æšå¼•ã</button>
                <button id="discard-selected-button" class="btn btn-primary" style="display: none;">é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹</button>
                <button id="check-button" class="btn btn-secondary" disabled>å½¹ã‚’åˆ¤å®šã™ã‚‹ (9æšå¿…é ˆ)</button>
                <button id="start-game-button" class="btn btn-secondary" style="display: none;">ã‚²ãƒ¼ãƒ é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿)</button>
            </div>
            <button class="btn" style="background-color: #777; color: white; margin-top: 15px;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>
        </div>
        
        <!-- ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒŠ -->
        <div id="chat-container">
            <h3 style="margin-top: 0; color: #555;">ãƒ«ãƒ¼ãƒ ãƒãƒ£ãƒƒãƒˆ</h3>
            <div id="messages-list">
                <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...">
                <button id="send-button" class="btn btn-secondary">é€ä¿¡</button>
            </div>
        </div>
    </div>

</div>

</body>
</html>
