<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firebaseé‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© - 2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script type="module">
        // Firebaseã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, updateDoc, arrayUnion, runTransaction, getDoc, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firestoreã®ãƒ­ã‚°ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š (ãƒ‡ãƒãƒƒã‚°ç”¨)
        setLogLevel('debug');

        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ï¼ˆCanvasç’°å¢ƒã‹ã‚‰æä¾›ã•ã‚Œã‚‹ã‚‚ã®ã‚’å–å¾—ï¼‰
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyBPMqx8KHacF0XiRLSRztgXiRHoGdXFpCQ",
            authDomain: "talk-to-friends-point.firebaseapp.com",
            projectId: "talk-to-friends-point",
            storageBucket: "talk-to-friends-point.firebaseapp.com",
            messagingSenderId: "1012267135320",
            appId: "1:1012267135320:web:1bb99aa6249c88bfac752d",
            measurementId: "G-RFX7NK1Q28"
        };
        
        const firebaseConfig = FIREBASE_CONFIG;
        const appId = typeof __app_id !== 'undefined' ? __app_id : FIREBASE_CONFIG.projectId;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Firebaseã‚µãƒ¼ãƒ“ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        let app;
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;

        // ã‚²ãƒ¼ãƒ é–¢é€£ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let roomId = '';
        let roomRef = null;
        let roomData = null;
        let unsubscribeRoom = null;
        let isHost = false; 
        
        let myPlayerIndex = -1; 
        let playerHand = [];
        let playerOpenTiles = []; // å…¬é–‹ç‰Œ (ãƒãƒ³ã§å›ºå®šã•ã‚ŒãŸç‰Œ)
        let isDrawingPhase = false; // true: ç‰Œã‚’å¼•ã„ãŸç›´å¾Œ (9æšçŠ¶æ…‹), false: ç‰Œã‚’æ¨ã¦ãŸç›´å¾Œ (8æšçŠ¶æ…‹)
        let selectedTileId = null;

        // ã‚²ãƒ¼ãƒ å®šæ•° (é‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ä»•æ§˜)
        const TILE_TYPES = [
            'P1', 'P2', 'P3', 'P4', 'P5', 'P6', 'P7', 'P8', 'P9'
        ]; // é‡çƒãƒã‚¸ã‚·ãƒ§ãƒ³ 1ã€œ9 (æŠ•æ‰‹ã€œãƒ©ã‚¤ãƒˆ)
        const TILE_NAMES = {
            'P1': 'æŠ•', 'P2': 'æ•', 'P3': 'ä¸€', 'P4': 'äºŒ', 'P5': 'ä¸‰', 'P6': 'éŠ', 'P7': 'å·¦', 'P8': 'ä¸­', 'P9': 'å³'
        };
        const SPECIAL_TILE = 'OT'; // å¤§è°·ç‰Œ
        const SPECIAL_TILE_NAME = 'å¤§è°·';

        const TILES_PER_TYPE = 5; // é€šå¸¸ç‰Œã¯å„5æš
        const SPECIAL_TILES_COUNT = 3; // å¤§è°·ç‰Œã¯3æš
        const HAND_SIZE_START = 8;
        const HAND_SIZE_WIN = 9;

        // DOMè¦ç´ ã®å–å¾—
        const lobbyContainer = document.getElementById('lobby-container');
        const gameContainer = document.getElementById('game-container');
        const drawButton = document.getElementById('draw-button');
        const checkButton = document.getElementById('check-button');
        const discardSelectedButton = document.getElementById('discard-selected-button');
        const ponButton = document.getElementById('pon-button'); // ãƒãƒ³ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
        const handContainer = document.getElementById('hand-container');
        const openTilesContainer = document.getElementById('open-tiles-container'); // å…¬é–‹ç‰Œã‚³ãƒ³ãƒ†ãƒŠ
        const opponentHandContainer = document.getElementById('opponent-hand-container');
        const opponentOpenTilesContainer = document.getElementById('opponent-open-tiles-container'); // ç›¸æ‰‹ã®å…¬é–‹ç‰Œã‚³ãƒ³ãƒ†ãƒŠ
        const deckCountDisplay = document.getElementById('deck-count');
        const discardContainer = document.getElementById('discard-container');
        const messageBox = document.getElementById('message-box');
        const connectionStatus = document.getElementById('connection-status');
        const currentTurnDisplay = document.getElementById('current-turn');
        const userIdDisplay = document.getElementById('user-id-display');
        
        // ãƒãƒ£ãƒƒãƒˆé–¢é€£DOMè¦ç´ 
        const messagesList = document.getElementById('messages-list');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');

        // -----------------------------------------------------
        // 1. FirebaseåˆæœŸåŒ–ã¨èªè¨¼
        // -----------------------------------------------------

        async function initFirebase() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                    isAuthReady = true;
                    userIdDisplay.textContent = `ã‚ãªãŸã®ID: ${userId}`;
                    displayMessage("èªè¨¼å®Œäº†ã€‚ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆã¾ãŸã¯å‚åŠ ã—ã¦ãã ã•ã„ã€‚", 'normal');
                    document.getElementById('loading-message').style.display = 'none';
                    lobbyContainer.style.display = 'block';
                    connectionStatus.textContent = 'åŒæœŸå¾…æ©Ÿä¸­...';
                    connectionStatus.style.backgroundColor = '#ccc';
                });

                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                }

            } catch (error) {
                console.error("FirebaseåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("FirebaseåˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        // -----------------------------------------------------
        // 2. ãƒ«ãƒ¼ãƒ ç®¡ç†ãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        function getRoomCollectionRef() {
            // ãƒ‘ãƒ–ãƒªãƒƒã‚¯ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³: /artifacts/{appId}/public/data/donjara_rooms
            return collection(db, 'artifacts', appId, 'public', 'data', 'donjara_rooms');
        }

        /**
         * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’åˆæœŸåŒ– (é‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ©ç‰Œæ§‹æˆ)
         */
        function createInitialRoomData() {
            let initialDeck = [];
            
            for (const type of TILE_TYPES) {
                for (let i = 1; i <= TILES_PER_TYPE; i++) {
                    initialDeck.push(`${type}-${i}`);
                }
            }
            for (let i = 1; i <= SPECIAL_TILES_COUNT; i++) {
                 initialDeck.push(`${SPECIAL_TILE}-${i}`);
            }
            shuffle(initialDeck);

            return {
                players: [],
                deck: initialDeck,
                discardedTiles: [],
                currentPlayerId: '',
                status: 'waiting', // 'waiting', 'playing', 'finished'
                messages: [],
                // ãƒãƒ³æ©Ÿèƒ½ã®ãŸã‚ã®çŠ¶æ…‹
                lastDiscardedTile: null, // æœ€å¾Œã«æ¨ã¦ã‚‰ã‚ŒãŸç‰Œ (ID)
                discarderId: null,      // æœ€å¾Œã«æ¨ã¦ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ID
                pendingAction: false,   // ãƒãƒ³å¾…ã¡çŠ¶æ…‹
                lastUpdated: Date.now()
            };
        }

        async function createRoom() {
            if (!isAuthReady || !userId) return;

            roomId = crypto.randomUUID().substring(0, 8);
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = true;

            try {
                const roomSnapshot = await getDoc(roomRef);
                if (roomSnapshot.exists()) {
                     displayMessage("ãƒ«ãƒ¼ãƒ IDãŒé‡è¤‡ã—ã¾ã—ãŸã€‚å†è©¦è¡Œã—ã¾ã™ã€‚", 'error');
                     return;
                }

                await setDoc(roomRef, createInitialRoomData());
                await joinRoom(roomId);
            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ ä½œæˆã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒ«ãƒ¼ãƒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        async function joinRoom(id) {
            if (!isAuthReady || !userId) return;
            roomId = id || document.getElementById('room-id-input').value.trim();
            roomRef = doc(getRoomCollectionRef(), roomId);
            isHost = false; 

            if (!roomId) {
                displayMessage("ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚", 'error');
                return;
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const roomSnapshot = await transaction.get(roomRef);
                    if (!roomSnapshot.exists()) {
                        throw new Error(`ãƒ«ãƒ¼ãƒ ID: ${roomId} ã¯å­˜åœ¨ã—ã¾ã›ã‚“ã€‚`);
                    }

                    const currentRoomData = roomSnapshot.data();
                    
                    if (currentRoomData.status !== 'waiting' || currentRoomData.players.length >= 2) {
                        throw new Error("ã“ã®ãƒ«ãƒ¼ãƒ ã¯æº€å“¡ã‹ã€æ—¢ã«ã‚²ãƒ¼ãƒ ãŒé–‹å§‹ã•ã‚Œã¦ã„ã¾ã™ã€‚");
                    }
                    
                    const existingPlayer = currentRoomData.players.find(p => p.userId === userId);
                    if (existingPlayer) {
                         myPlayerIndex = currentRoomData.players.indexOf(existingPlayer);
                         return;
                    }

                    const isNewHost = currentRoomData.players.length === 0;
                    // openTilesã‚’åˆæœŸåŒ–ã«è¿½åŠ 
                    const newPlayer = { userId, hand: [], openTiles: [], isHost: isNewHost };
                    const newPlayers = [...currentRoomData.players, newPlayer];
                    myPlayerIndex = newPlayers.length - 1; 

                    transaction.update(roomRef, {
                        players: newPlayers,
                        lastUpdated: Date.now()
                    });
                    
                    isHost = isNewHost;
                });

                document.getElementById('room-title').textContent = `ãƒ«ãƒ¼ãƒ ID: ${roomId}`;
                lobbyContainer.style.display = 'none';
                gameContainer.style.display = 'flex';
                document.getElementById('game-content').style.display = 'block';

                startRoomListener();
                connectionStatus.textContent = 'åŒæœŸä¸­ (Firebase)';
                connectionStatus.style.backgroundColor = '#4CAF50'; 

            } catch (error) {
                console.error("ãƒ«ãƒ¼ãƒ å‚åŠ ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ãƒ«ãƒ¼ãƒ å‚åŠ å¤±æ•—: ${error.message}`, 'error');
            }
        }
        
        /**
         * ãƒ«ãƒ¼ãƒ ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦– (FirebaseåŒæœŸã®ã‚³ã‚¢)
         */
        function startRoomListener() {
            if (unsubscribeRoom) {
                unsubscribeRoom();
            }
            unsubscribeRoom = onSnapshot(roomRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const oldData = roomData;
                    roomData = docSnapshot.data();
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã®åŒæœŸ
                    const myState = roomData.players.find(p => p.userId === userId);
                    if (myState) {
                        myPlayerIndex = roomData.players.indexOf(myState);
                        playerHand = myState.hand || [];
                        playerOpenTiles = myState.openTiles || [];
                        isHost = myState.isHost;
                    }
                    
                    // ã‚¿ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆæ™‚ã®isDrawingPhaseæ›´æ–°
                    if (oldData && oldData.currentPlayerId !== roomData.currentPlayerId) {
                         if (roomData.currentPlayerId === userId) {
                             // è‡ªåˆ†ã®ã‚¿ãƒ¼ãƒ³ã«ãªã£ãŸæ™‚ã€æ‰‹ç‰Œã®æšæ•°ã«å¿œã˜ã¦ãƒ•ã‚§ãƒ¼ã‚ºã‚’è¨­å®š
                             isDrawingPhase = playerHand.length >= HAND_SIZE_WIN; // ãƒãƒ³å¾Œã®æ¨ç‰Œ or ãƒ„ãƒ¢å¾Œã®æ¨ç‰Œ
                             displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã™ã€‚", 'success');
                             selectedTileId = null; 
                         } else {
                              isDrawingPhase = false; 
                         }
                    }

                    if (roomData.status === 'finished') {
                        endGame(roomData.winnerId || null);
                        return;
                    }

                    // UIã®æ›´æ–°
                    updateUI(); 
                    updateGameUI(roomData);
                    
                    if (roomData.messages) {
                        renderMessages(roomData.messages);
                    }

                } else {
                    displayMessage("ãƒ«ãƒ¼ãƒ ã¯å‰Šé™¤ã•ã‚Œã¾ã—ãŸã€‚", 'error');
                    if (unsubscribeRoom) {
                        unsubscribeRoom();
                        unsubscribeRoom = null;
                    }
                    location.reload(); 
                }
            });
        }
        
        async function startGame() {
            if (!isHost || roomData.status !== 'waiting' || roomData.players.length !== 2) return;

            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.players.length !== 2) return;

                    // å…¬é–‹ç‰Œã‚’åˆæœŸåŒ–ã«è¿½åŠ 
                    const players = currentRoomData.players.map(p => ({ ...p, hand: [], openTiles: [] }));
                    let deck = currentRoomData.deck;

                    for (let i = 0; i < HAND_SIZE_START; i++) {
                        players.forEach(p => {
                            const tile = deck.pop();
                            if(tile) p.hand.push(tile); 
                        });
                    }

                    const startingPlayerId = players[Math.floor(Math.random() * 2)].userId;

                    transaction.update(roomRef, {
                        players: players,
                        deck: deck,
                        currentPlayerId: startingPlayerId,
                        status: 'playing',
                        lastDiscardedTile: null,
                        discarderId: null,
                        pendingAction: false,
                        lastUpdated: Date.now()
                    });
                });
            } catch (error) {
                console.error("ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ã‚²ãƒ¼ãƒ é–‹å§‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }
        
        // -----------------------------------------------------
        // 3. UI/è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------
        
        function displayMessage(text, type = 'normal') {
            messageBox.textContent = text;
            messageBox.className = '';
            messageBox.classList.add('message-box');
            if (type === 'success') {
                messageBox.classList.add('message-success');
            } else if (type === 'error') {
                messageBox.classList.add('message-error');
            } else {
                 messageBox.classList.add('message-normal');
            }
        }

        function updateGameUI(data) {
            if (!data || data.status !== 'playing') {
                // ... (ãƒ­ãƒ“ãƒ¼è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ã¯çœç•¥)
                currentTurnDisplay.textContent = 'ã‚²ãƒ¼ãƒ å¾…ã¡';
                currentTurnDisplay.style.backgroundColor = '#ccc';
                drawButton.disabled = true;
                checkButton.disabled = true;
                discardSelectedButton.style.display = 'none';
                ponButton.style.display = 'none';
                document.getElementById('start-game-button').style.display = (isHost && data && data.players.length === 2 && data.status === 'waiting') ? 'inline-block' : 'none';
                
                const playersInfo = data ? data.players.map(p => 
                    `${p.userId === userId ? 'ã‚ãªãŸ (Me)' : 'å¯¾æˆ¦ç›¸æ‰‹ (Opponent)'} ${p.isHost ? '(HOST)' : ''}`
                ).join(' / ') : 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: 1äºº';
                document.getElementById('player-list').textContent = playersInfo;
                
                return;
            }
            
            const myTurn = data.currentPlayerId === userId;
            const opponentPlayerState = data.players.find(p => p.userId !== userId);
            
            // ãƒãƒ³å¾…ã¡çŠ¶æ…‹ã‹ï¼Ÿ
            const isPonPending = data.pendingAction && data.discarderId !== userId;
            
            // ã‚¿ãƒ¼ãƒ³è¡¨ç¤º
            currentTurnDisplay.textContent = myTurn ? 'ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³' : 'ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³';
            currentTurnDisplay.style.backgroundColor = myTurn ? '#aaffaa' : '#ffaaaa';
            
            // ãƒãƒ³å¯èƒ½ãƒã‚§ãƒƒã‚¯
            const canPon = isPonPending && isPossiblePon(data.lastDiscardedTile, playerHand);
            
            // ãƒœã‚¿ãƒ³åˆ¶å¾¡
            drawButton.disabled = !myTurn || isDrawingPhase || data.deck.length === 0 || isPonPending;
            checkButton.disabled = !myTurn || playerHand.length !== HAND_SIZE_WIN || isPonPending;
            discardSelectedButton.style.display = (myTurn && isDrawingPhase) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTileId;
            
            // ãƒãƒ³ãƒœã‚¿ãƒ³ã®è¡¨ç¤º
            ponButton.style.display = canPon ? 'inline-block' : 'none';
            drawButton.style.display = isPonPending ? 'none' : 'inline-block'; // ãƒãƒ³å¾…ã¡ä¸­ã¯å±±æœ­ã‚’å¼•ã‘ãªã„
            
            // ãƒãƒ³å¾…ã¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
            if (isPonPending && !canPon && !myTurn) {
                displayMessage("ç›¸æ‰‹ã®æ¨ç‰Œã‚’ãƒãƒ³ã§ãã‚‹ã‹ç¢ºèªä¸­ã§ã™ã€‚", 'normal');
            }
            if (canPon) {
                const tileType = data.lastDiscardedTile.substring(0, 2);
                const tileDisplayName = tileType === SPECIAL_TILE ? SPECIAL_TILE_NAME : TILE_NAMES[tileType];
                displayMessage(`å¯¾æˆ¦ç›¸æ‰‹ãŒ${tileDisplayName}ã‚’æ¨ã¦ã¾ã—ãŸã€‚ãƒãƒ³ã—ã¾ã™ã‹ï¼Ÿ`, 'success');
            }


            // å±±æœ­ã¨æ¨ã¦ç‰Œ
            deckCountDisplay.textContent = data.deck.length;
            renderDiscardedTiles(data.discardedTiles);

            // ç›¸æ‰‹ã®æ‰‹ç‰Œã¨å…¬é–‹ç‰Œ
            opponentHandContainer.innerHTML = '';
            opponentOpenTilesContainer.innerHTML = '';
            if (opponentPlayerState) {
                const opponentHandSize = opponentPlayerState.hand.length;
                for (let i = 0; i < opponentHandSize; i++) {
                    opponentHandContainer.appendChild(Object.assign(document.createElement('div'), { className: 'tile face-down' }));
                }
                renderOpenTiles(opponentPlayerState.openTiles, opponentOpenTilesContainer, true);
            }
        }
        
        /**
         * æ‰‹ç‰ŒUIã‚’æ›´æ–°
         */
        function updateUI() {
            // æ‰‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            handContainer.innerHTML = '';
            playerHand.sort((a, b) => {
                const typeA = a.substring(0, 2);
                const typeB = b.substring(0, 2);
                if (typeA === SPECIAL_TILE && typeB !== SPECIAL_TILE) return 1;
                if (typeA !== SPECIAL_TILE && typeB === SPECIAL_TILE) return -1;
                return a.localeCompare(b);
            });

            playerHand.forEach(tileId => {
                const tileEl = createTileElement(tileId);
                if (tileId === selectedTileId) {
                     tileEl.classList.add('selected');
                }
                handContainer.appendChild(tileEl);
            });
            
            // å…¬é–‹ç‰Œã®è¡¨ç¤ºæ›´æ–°
            renderOpenTiles(playerOpenTiles, openTilesContainer);

            // é¸æŠçŠ¶æ…‹ã®æ›´æ–°ã«å¿œã˜ã¦æ¨ã¦ã‚‹ãƒœã‚¿ãƒ³ã‚’åˆ¶å¾¡
            const selectedTile = handContainer.querySelector('.tile.selected');
            const myTurn = roomData && roomData.currentPlayerId === userId;
            
            discardSelectedButton.style.display = (myTurn && isDrawingPhase) ? 'inline-block' : 'none';
            discardSelectedButton.disabled = !selectedTile;
            
            document.getElementById('hand-count').textContent = playerHand.length;
        }

        /**
         * å…¬é–‹ç‰Œã®ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
         */
        function renderOpenTiles(openSets, container, isOpponent = false) {
            container.innerHTML = '';
            openSets.forEach(set => {
                const setContainer = document.createElement('div');
                setContainer.className = 'open-tile-set';
                // 3æšã®ç‰Œã‚’ã‚»ãƒƒãƒˆã¨ã—ã¦è¡¨ç¤º
                set.forEach(tileId => {
                    setContainer.appendChild(createTileElement(tileId, false));
                });
                container.appendChild(setContainer);
            });
        }

        /**
         * ç‰ŒDOMè¦ç´ ã®ç”Ÿæˆ
         */
        function createTileElement(tileId, selectable = true) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            tile.setAttribute('data-id', tileId);
            const type = tileId.substring(0, 2);
            tile.setAttribute('data-type', type);
            
            if (type === SPECIAL_TILE) {
                tile.textContent = SPECIAL_TILE_NAME;
                tile.classList.add('special-tile');
                tile.title = "å¤§è°·ç‰Œ (ã‚ªãƒ¼ãƒ«ãƒã‚¤ãƒ†ã‚£)"; 
            } else {
                tile.textContent = TILE_NAMES[type] || type; 
            }

            if (selectable) {
                tile.addEventListener('click', handleTileClick);
            }
            return tile;
        }
        
        function renderDiscardedTiles(tiles) {
            discardContainer.innerHTML = '';
            // æœ€æ–°ã®15æšã‚’è¡¨ç¤º
            tiles.slice(-15).forEach(tileId => {
                 discardContainer.appendChild(createTileElement(tileId, false));
            });
        }

        function handleTileClick(event) {
            // ãƒãƒ³å¾Œã®æ¨ç‰Œ or ãƒ„ãƒ¢å¾Œã®æ¨ç‰Œæ™‚ã®ã¿é¸æŠå¯èƒ½
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase) {
                displayMessage("ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã§ã€ç‰Œã‚’å¼•ã„ãŸå¾Œã§ã®ã¿æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã§ãã¾ã™ã€‚", 'error');
                return;
            }

            const tileElement = event.currentTarget;
            const tileId = tileElement.getAttribute('data-id');

            const isSelected = tileElement.classList.contains('selected');
            
            // å…¨ã¦ãƒªã‚»ãƒƒãƒˆ
            handContainer.querySelectorAll('.tile.selected').forEach(t => t.classList.remove('selected'));
            selectedTileId = null;

            if (!isSelected) {
                // æ–°ã—ãé¸æŠ
                tileElement.classList.add('selected');
                selectedTileId = tileId;
                const tileDisplayName = (tileId.startsWith(SPECIAL_TILE)) ? SPECIAL_TILE_NAME : TILE_NAMES[tileId.substring(0, 2)];
                displayMessage(`${tileDisplayName}ã®ç‰Œã‚’é¸æŠã—ã¾ã—ãŸã€‚ã“ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€å½¹åˆ¤å®šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚`);
            } else {
                displayMessage("æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚");
            }
            updateGameUI(roomData);
        }
        
        // -----------------------------------------------------
        // 4. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ (Firestoreã¸ã®æ›¸ãè¾¼ã¿)
        // -----------------------------------------------------

        /**
         * å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã
         */
        async function drawTile() {
            if (!roomData || roomData.currentPlayerId !== userId || isDrawingPhase || roomData.deck.length === 0 || roomData.pendingAction) return;
            
            try {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    if (currentRoomData.currentPlayerId !== userId || currentRoomData.deck.length === 0 || currentRoomData.players[myPlayerIndex].hand.length !== HAND_SIZE_START) {
                        throw new Error("ã‚¿ãƒ¼ãƒ³ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€ã¾ãŸã¯å±±æœ­ãŒç©ºã‹ã€æ—¢ã«å¼•ã„ã¦ã„ã¾ã™ã€‚");
                    }

                    const drawnTile = currentRoomData.deck.pop();
                    currentRoomData.players[myPlayerIndex].hand.push(drawnTile);

                    transaction.update(roomRef, {
                        deck: currentRoomData.deck,
                        players: currentRoomData.players,
                        lastUpdated: Date.now()
                    });
                });

                isDrawingPhase = true;
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                displayMessage("å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ãã¾ã—ãŸ (æ‰‹ç‰Œ9æš)ã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", 'success');

            } catch (error) {
                console.error("ç‰Œã‚’å¼•ãã‚¨ãƒ©ãƒ¼:", error);
                displayMessage(`ç‰Œã‚’å¼•ãã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }

        /**
         * é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹
         */
        async function discardSelectedTile() {
            if (!roomData || roomData.currentPlayerId !== userId || !isDrawingPhase || !selectedTileId) return;

            const tileIdToDiscard = selectedTileId;
            const tileType = tileIdToDiscard.substring(0, 2);

            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    const currentHand = currentRoomData.players[myPlayerIndex].hand;
                    const tileIndex = currentHand.indexOf(tileIdToDiscard);
                    
                    if (tileIndex === -1) {
                         throw new Error("æ¨ã¦ã‚‹ç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    }
                    
                    // æ¨ã¦ã‚‹
                    currentHand.splice(tileIndex, 1);
                    currentRoomData.discardedTiles.push(tileIdToDiscard);

                    // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’æ±ºå®š
                    const opponent = currentRoomData.players.find(p => p.userId !== userId);
                    const nextPlayerId = opponent.userId;

                    // ãƒãƒ³å¾…ã¡çŠ¶æ…‹ã‚’è¨­å®š
                    const updateData = {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        lastDiscardedTile: tileIdToDiscard,
                        discarderId: userId,
                        pendingAction: true, // ãƒãƒ³å¾…ã¡çŠ¶æ…‹ã¸ç§»è¡Œ
                        currentPlayerId: userId, // ã‚¿ãƒ¼ãƒ³ã¯ä¸€æ—¦è‡ªåˆ†ã«ä¿æŒ (ç›¸æ‰‹ã®ãƒãƒ³ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å¾…ã¤)
                        lastUpdated: Date.now()
                    };

                    transaction.update(roomRef, updateData);
                });

                // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æˆåŠŸå¾Œã®ãƒ­ãƒ¼ã‚«ãƒ«UIæ›´æ–°
                isDrawingPhase = false;
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                const tileDisplayName = (tileType === SPECIAL_TILE) ? SPECIAL_TILE_NAME : TILE_NAMES[tileType];
                displayMessage(`${tileDisplayName}ã‚’æ¨ã¦ã¾ã—ãŸã€‚ç›¸æ‰‹ã®åå¿œã‚’å¾…ã£ã¦ã„ã¾ã™...`);

            } catch (error) {
                 console.error("ç‰Œã‚’æ¨ã¦ã‚‹ã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`ç‰Œã‚’æ¨ã¦ã‚‹ã®ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }
        
        /**
         * ç›¸æ‰‹ã®æ¨ç‰Œã‚’ãƒãƒ³ã§ãã‚‹ã‹åˆ¤å®š (ãƒ­ãƒ¼ã‚«ãƒ«é–¢æ•°)
         */
        function isPossiblePon(discardedTileId, hand) {
            if (!discardedTileId) return false;
            
            const discardedType = discardedTileId.substring(0, 2);
            if (!discardedType) return false;
            
            const handTypes = hand.map(id => id.substring(0, 2));
            const handCounts = handTypes.reduce((acc, type) => {
                acc[type] = (acc[type] || 0) + 1;
                return acc;
            }, {});

            const myTypeCount = handCounts[discardedType] || 0;
            const otaniCount = handCounts[SPECIAL_TILE] || 0;
            
            // åˆ»å­ã‚’ä½œã‚‹ã«ã¯ã€è‡ªåˆ†ã®æ‰‹ç‰Œã«åŒã˜ç‰ŒãŒ2æšå¿…è¦
            return myTypeCount + otaniCount >= 2;
        }

        /**
         * ãƒãƒ³ã‚’å®Ÿè¡Œ
         */
        async function executePon() {
            if (!roomData || roomData.currentPlayerId === roomData.discarderId || !roomData.pendingAction) return;
            const discardedTileId = roomData.lastDiscardedTile;
            if (!discardedTileId || !isPossiblePon(discardedTileId, playerHand)) {
                displayMessage("ãƒãƒ³ã¯ã§ãã¾ã›ã‚“ã€‚", 'error');
                return;
            }

            const discardedType = discardedTileId.substring(0, 2);
            
            try {
                 await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    const myState = currentRoomData.players[myPlayerIndex];
                    
                    // 1. ãƒãƒ³ç‰Œï¼ˆæ¨ã¦ç‰Œï¼‰ã‚’æ¨ã¦ç‰Œãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
                    const lastDiscardedIndex = currentRoomData.discardedTiles.lastIndexOf(discardedTileId);
                    if (lastDiscardedIndex === -1) throw new Error("æ¨ã¦ç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚");
                    currentRoomData.discardedTiles.splice(lastDiscardedIndex, 1);

                    // 2. æ‰‹ç‰Œã‹ã‚‰ãƒãƒ³ã«å¿…è¦ãª2æšã‚’æ¢ã—ã¦å‰Šé™¤
                    const neededCount = 2;
                    let removedCount = 0;
                    const handToRemove = [];

                    // å„ªå…ˆåº¦1: é€šå¸¸ç‰Œ
                    for (let i = myState.hand.length - 1; i >= 0 && removedCount < neededCount; i--) {
                        if (myState.hand[i].startsWith(discardedType)) {
                            handToRemove.push(myState.hand.splice(i, 1)[0]);
                            removedCount++;
                        }
                    }
                    
                    // å„ªå…ˆåº¦2: å¤§è°·ç‰Œã§è£œå®Œ
                    if (removedCount < neededCount) {
                        for (let i = myState.hand.length - 1; i >= 0 && removedCount < neededCount; i--) {
                            if (myState.hand[i].startsWith(SPECIAL_TILE)) {
                                handToRemove.push(myState.hand.splice(i, 1)[0]);
                                removedCount++;
                            }
                        }
                    }
                    
                    if (removedCount !== neededCount) throw new Error("ãƒãƒ³ã«å¿…è¦ãªç‰ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
                    
                    // 3. å…¬é–‹ç‰Œãƒªã‚¹ãƒˆã«è¿½åŠ 
                    const newOpenSet = [discardedTileId, ...handToRemove];
                    myState.openTiles.push(newOpenSet);
                    
                    // 4. ãƒ«ãƒ¼ãƒ çŠ¶æ…‹ã®æ›´æ–°
                    const opponent = currentRoomData.players.find(p => p.userId === currentRoomData.discarderId);
                    
                    currentRoomData.currentPlayerId = userId; // ãƒãƒ³ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¿ãƒ¼ãƒ³ãŒç§»ã‚‹
                    currentRoomData.pendingAction = false;
                    currentRoomData.lastDiscardedTile = null;
                    currentRoomData.discarderId = null;

                    transaction.update(roomRef, {
                        players: currentRoomData.players,
                        discardedTiles: currentRoomData.discardedTiles,
                        currentPlayerId: userId,
                        pendingAction: false,
                        lastDiscardedTile: null,
                        discarderId: null,
                        lastUpdated: Date.now()
                    });
                });
                
                // ãƒãƒ³æˆåŠŸå¾Œã®UIæ›´æ–°
                isDrawingPhase = true; // ãƒãƒ³å¾Œã¯æ¨ç‰ŒãŒå¿…è¦
                selectedTileId = null;
                updateUI();
                updateGameUI(roomData);
                const tileDisplayName = (discardedType === SPECIAL_TILE) ? SPECIAL_TILE_NAME : TILE_NAMES[discardedType];
                displayMessage(`${tileDisplayName}ã‚’ãƒãƒ³ã—ã¾ã—ãŸã€‚æ¨ã¦ã‚‹ç‰Œã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`, 'success');

            } catch (error) {
                 console.error("ãƒãƒ³å®Ÿè¡Œã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`ãƒãƒ³å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }
        
        /**
         * ãƒãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã€ã‚¿ãƒ¼ãƒ³ã‚’ç›¸æ‰‹ã«æ¸¡ã™
         */
        async function skipPon() {
             if (!roomData || roomData.currentPlayerId === roomData.discarderId || !roomData.pendingAction) return;

             try {
                await runTransaction(db, async (transaction) => {
                    const currentRoomData = (await transaction.get(roomRef)).data();
                    
                    // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼IDã‚’æ±ºå®š (ãƒãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã®ã§ã€æ¨ã¦ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ¬¡ã®ç•ª)
                    const opponent = currentRoomData.players.find(p => p.userId === currentRoomData.discarderId);
                    const nextPlayer = currentRoomData.players.find(p => p.userId !== opponent.userId);

                    transaction.update(roomRef, {
                        currentPlayerId: nextPlayer.userId, // ãƒãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã®ã§ã€æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚¿ãƒ¼ãƒ³ã‚’æ¸¡ã™
                        pendingAction: false,
                        lastDiscardedTile: null,
                        discarderId: null,
                        lastUpdated: Date.now()
                    });
                });
                displayMessage("ãƒãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã€ã‚ãªãŸã®ã‚¿ãƒ¼ãƒ³ã«ãªã‚Šã¾ã—ãŸã€‚å±±æœ­ã‹ã‚‰ç‰Œã‚’å¼•ã„ã¦ãã ã•ã„ã€‚", 'normal');

            } catch (error) {
                 console.error("ãƒãƒ³ ã‚¹ã‚­ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼:", error);
                 displayMessage(`ãƒãƒ³ ã‚¹ã‚­ãƒƒãƒ—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`, 'error');
            }
        }


        /**
         * å½¹ã®åˆ¤å®šã‚’å®Ÿè¡Œ
         */
        async function checkHandForYaku() {
            if (!roomData || roomData.currentPlayerId !== userId || playerHand.length !== HAND_SIZE_WIN) return;

            const isYaku = checkYaku([...playerHand, ...playerOpenTiles.flat()]);

            if (isYaku) {
                displayMessage("ğŸ‰ å½¹ãŒæˆç«‹ã—ã¾ã—ãŸï¼ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ ğŸ‰", 'success');
                await updateDoc(roomRef, { 
                    status: 'finished', 
                    winnerId: userId 
                });
            } else {
                displayMessage("å½¹ã¯æˆç«‹ã—ã¦ã„ã¾ã›ã‚“ã€‚åˆ¥ã®ç‰Œã‚’æ¨ã¦ã‚‹ã‹ã€æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚", 'error');
            }
        }
        
        /**
         * å½¹ã®åˆ¤å®š (æ‰‹ç‰Œ9æš + å…¬é–‹ç‰Œã®åˆè¨ˆãŒã€Œ3æšçµ„Ã—3ã€ã¨ã€Œé›€é ­(2æšçµ„)Ã—1ã€ã®æ§‹æˆå¯èƒ½ã‹)
         */
        function checkYaku(allTiles) {
            // å…¬é–‹ç‰Œã¯æ—¢ã«3æšçµ„ã¨ã—ã¦ç¢ºå®šã—ã¦ã„ã‚‹ãŸã‚ã€æ®‹ã‚Šã®ç‰Œã ã‘ã§é›€é ­ã¨3æšçµ„ã‚’ä½œã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
            // é›€é ­ (2æš) + 3æšçµ„ * 2 = 8æšã€‚
            // 9æšã®æ‰‹ç‰Œã‹ã‚‰1æšã‚’æ¨ã¦ã‚‹å‰æã§ã€æ‰‹ç‰Œ + å…¬é–‹ç‰Œã®åˆè¨ˆãŒ 8æš + å…¬é–‹ç‰Œæ•° ã«ãªã£ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
            const totalHandSize = playerHand.length + playerOpenTiles.flat().length;

            // é³´ããªã— (å…¬é–‹ç‰Œãªã—) ã®å ´åˆã¯ã€9æšã®æ‰‹ç‰Œã‹ã‚‰1æšã‚’é¸ã³ã€æ®‹ã‚Šã®8æšã§åˆ¤å®š
            if (playerOpenTiles.length === 0) {
                 if (playerHand.length !== HAND_SIZE_WIN) return false;
                 for (let i = 0; i < playerHand.length; i++) {
                     const eightTiles = [...playerHand.slice(0, i), ...playerHand.slice(i + 1)];
                     if (canFormYaku(eightTiles)) {
                         return true;
                     }
                 }
                 return false;
            } else {
                // é³´ãã‚ã‚Š (å…¬é–‹ç‰Œã‚ã‚Š) ã®å ´åˆã¯ã€æ‰‹ç‰ŒãŒ 9 - (å…¬é–‹ç‰Œæ•° * 3) + 1 æšã«ãªã£ã¦ã„ã‚‹ã¯ãšã€‚
                // 9æšã®æ‰‹ç‰Œã‹ã‚‰1æšã‚’æ¨ã¦ãŸæ®‹ã‚Š (8æš) + å…¬é–‹ç‰Œã®åˆè¨ˆã§å½¹ãŒæˆç«‹ã™ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹
                // ãƒãƒ³å¾Œã®æ‰‹ç‰Œã¯8æšãªã®ã§ã€ãã®ã¾ã¾å½¹åˆ¤å®š
                if (playerHand.length === HAND_SIZE_START) {
                    return canFormYaku(playerHand, playerOpenTiles.length);
                }
                // ãƒãƒ³ç›´å¾Œã®9æšçŠ¶æ…‹ã‹ã‚‰1æšæ¨ã¦ã¦ã‚¢ã‚¬ã‚‹å ´åˆ
                if (playerHand.length === HAND_SIZE_WIN) {
                    for (let i = 0; i < playerHand.length; i++) {
                        const eightTiles = [...playerHand.slice(0, i), ...playerHand.slice(i + 1)];
                        if (canFormYaku(eightTiles, playerOpenTiles.length)) {
                            return true;
                        }
                    }
                    return false;
                }
            }
            return false;
        }

        /**
         * 8æšã®æ‰‹ç‰ŒãŒã€Œ3æšçµ„Ã—(2 + openSets)ã€ã¨ã€Œé›€é ­(2æšçµ„)Ã—1ã€ã§æ§‹æˆå¯èƒ½ã‹ã‚’åˆ¤å®š
         * openSetsCount: æ—¢ã«å…¬é–‹ã•ã‚Œã¦ã„ã‚‹3æšçµ„ã®æ•°
         */
        function canFormYaku(hand, openSetsCount = 0) {
             const requiredSets = 2 + openSetsCount; // å¿…è¦ãª3æšçµ„ã®ç·æ•° (æ‰‹ç‰Œå†…ã§ä½œã‚‹ã¹ãã¯ 2å€‹)
             const requiredHandSize = 8;
             if (hand.length !== requiredHandSize) return false;

             const counts = {};
             let otaniCount = 0;
             hand.forEach(id => {
                 const type = id.substring(0, 2);
                 if (type === SPECIAL_TILE) {
                     otaniCount++;
                 } else {
                     counts[type] = (counts[type] || 0) + 1;
                 }
             });

             const uniqueTypes = Object.keys(counts);
             const allTypes = [...uniqueTypes, SPECIAL_TILE];

             // é›€é ­ï¼ˆ2æšçµ„ï¼‰ã‚’æ¢ã—ã€æ®‹ã‚Šã®6æšã§2ã‚»ãƒƒãƒˆï¼ˆ3æšçµ„Ã—2ï¼‰ã‚’æ§‹æˆã§ãã‚‹ã‹ãƒã‚§ãƒƒã‚¯
             for (const headType of allTypes) {
                 let tempOtaniCount = otaniCount;
                 let tempCounts = { ...counts };
                 let canFormHead = false;
                 
                 // é›€é ­ã‚’å¤§è°·ç‰Œ2æšã§æ§‹æˆ (ä¸å¯èƒ½) -> ã‚¹ã‚­ãƒƒãƒ—
                 if (headType === SPECIAL_TILE) continue;
                 
                 // é›€é ­ã®å€™è£œç‰ŒãŒå­˜åœ¨ã—ãªã„ã‹ã€æ—¢ã«ä½¿ã‚ã‚Œã¦ã„ã‚‹ç‰Œã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
                 if (!tempCounts[headType] && headType !== SPECIAL_TILE) continue;

                 // é›€é ­ã‚’é€šå¸¸ç‰Œ2æšã§æ§‹æˆ
                 if (tempCounts[headType] >= 2) {
                     tempCounts[headType] -= 2;
                     canFormHead = true;
                 } 
                 // é›€é ­ã‚’é€šå¸¸ç‰Œ1æš+å¤§è°·ç‰Œ1æšã§æ§‹æˆ
                 else if (tempCounts[headType] >= 1 && tempOtaniCount >= 1) {
                     tempCounts[headType] -= 1;
                     tempOtaniCount -= 1;
                     canFormHead = true;
                 } 
                 
                 if (canFormHead) {
                     // é›€é ­ã‚’é™¤ã„ãŸæ®‹ã‚Šã®6æšï¼ˆ3æšçµ„Ã—2ï¼‰ã§æ§‹æˆå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                     const remainingTiles = [];
                     for (const type in tempCounts) {
                          for (let i = 0; i < tempCounts[type]; i++) {
                              remainingTiles.push(type); 
                          }
                     }
                     
                     // æ®‹ã‚Š6æšï¼ˆ3æšçµ„Ã—2ï¼‰ã§æ§‹æˆå¯èƒ½ã‹å†å¸°çš„ã«ãƒã‚§ãƒƒã‚¯
                     if (canFormSets(remainingTiles, tempOtaniCount, 2)) {
                          return true;
                     }
                 }
             }

             return false;
        }
        
        /**
         * æ®‹ã‚Šã®æ‰‹ç‰ŒãŒå…¨ã¦3æšçµ„ã§æ§‹æˆå¯èƒ½ã‹ã‚’ãƒã‚§ãƒƒã‚¯ (å†å¸°é–¢æ•°)
         * tiles: æ®‹ã‚Šã®ç‰Œã‚¿ã‚¤ãƒ—é…åˆ—
         * otaniCount: æ®‹ã‚Šã®å¤§è°·ç‰Œã®æ•°
         * setsToFind: ä½œæˆã™ã¹ã3æšçµ„ã®æ•° (é€šå¸¸ã¯2)
         */
        function canFormSets(tiles, otaniCount, setsToFind) {
             if (setsToFind === 0) return tiles.length === 0;
             if (tiles.length + otaniCount < setsToFind * 3) return false;

             const counts = {};
             tiles.forEach(type => {
                 counts[type] = (counts[type] || 0) + 1;
             });

             const sortedTypes = Object.keys(counts).sort((a, b) => a.localeCompare(b));
             const firstType = sortedTypes.find(type => counts[type] > 0);
             if (!firstType) return otaniCount >= setsToFind * 3;

             let result = false;
             
             // æ¬¡ã®å†å¸°å‡¦ç†ã®ãŸã‚ã«æ®‹ã‚Šã®ç‰Œã‚’æº–å‚™ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼
             const getNextTiles = (currentCounts) => {
                 const nextTiles = [];
                 for (const type in currentCounts) {
                      for (let i = 0; i < currentCounts[type]; i++) {
                          nextTiles.push(type);
                      }
                 }
                 return nextTiles;
             };

             // --- 1. åˆ»å­ (3æš) ã®æ§‹æˆ ---
             // 1-1. é€šå¸¸ç‰Œã®ã¿ã§æ§‹æˆ (3æš)
             if (counts[firstType] >= 3) {
                 counts[firstType] -= 3;
                 result = canFormSets(getNextTiles(counts), otaniCount, setsToFind - 1);
                 counts[firstType] += 3; // backtrack
                 if (result) return true;
             }

             // 1-2. å¤§è°·ç‰Œã‚’ä½¿ç”¨ã—ã¦æ§‹æˆ (2æš+å¤§è°·1 or 1æš+å¤§è°·2)
             if (otaniCount >= 1 && counts[firstType] >= 2) { // 2æš+å¤§è°·1
                 counts[firstType] -= 2;
                 result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                 counts[firstType] += 2; // backtrack
                 if (result) return true;
             }
             if (otaniCount >= 2 && counts[firstType] >= 1) { // 1æš+å¤§è°·2
                 counts[firstType] -= 1;
                 result = canFormSets(getNextTiles(counts), otaniCount - 2, setsToFind - 1);
                 counts[firstType] += 1; // backtrack
                 if (result) return true;
             }
             if (otaniCount >= 3) { // 0æš+å¤§è°·3
                 result = canFormSets(tiles, otaniCount - 3, setsToFind - 1);
                 if (result) return true;
             }
             
             // --- 2. é †å­ (é€£ç•ª3æš) ã®æ§‹æˆ ---
             const num1 = parseInt(firstType.substring(1));
             if (firstType.startsWith('P') && num1 >= 1 && num1 <= 7) {
                 const type2 = `P${num1 + 1}`;
                 const type3 = `P${num1 + 2}`;
                 
                 // 2-1. é€šå¸¸ç‰Œã®ã¿ã§æ§‹æˆ (P1, P2, P3)
                 if (counts[type2] > 0 && counts[type3] > 0) {
                      counts[firstType]--;
                      counts[type2]--;
                      counts[type3]--;
                      result = canFormSets(getNextTiles(counts), otaniCount, setsToFind - 1);
                      counts[firstType]++; counts[type2]++; counts[type3]++; // backtrack
                      if (result) return true;
                 }

                 // 2-2. å¤§è°·ç‰Œ1æšä½¿ç”¨ (ä¾‹: P1, P2, OT)
                 if (otaniCount >= 1) {
                    // P1, P2, OT
                    if (counts[firstType] > 0 && counts[type2] > 0) {
                        counts[firstType]--; counts[type2]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[firstType]++; counts[type2]++;
                        if (result) return true;
                    }

                    // P1, OT, P3
                    if (counts[firstType] > 0 && counts[type3] > 0) {
                        counts[firstType]--; counts[type3]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[firstType]++; counts[type3]++;
                        if (result) return true;
                    }
                    
                    // OT, P2, P3
                    if (counts[type2] > 0 && counts[type3] > 0) {
                        counts[type2]--; counts[type3]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 1, setsToFind - 1);
                        counts[type2]++; counts[type3]++;
                        if (result) return true;
                    }
                 }
                 
                 // 2-3. å¤§è°·ç‰Œ2æšä½¿ç”¨ (ä¾‹: P1, OT, OT)
                 if (otaniCount >= 2) {
                    // P1, OT, OT
                    if (counts[firstType] > 0) {
                        counts[firstType]--;
                        result = canFormSets(getNextTiles(counts), otaniCount - 2, setsToFind - 1);
                        counts[firstType]++;
                        if (result) return true;
                    }
                 }
             }

             return false;
        }

        // -----------------------------------------------------
        // 5. ãƒãƒ£ãƒƒãƒˆãƒ­ã‚¸ãƒƒã‚¯
        // -----------------------------------------------------

        async function sendMessage() {
            if (!isAuthReady || !roomId || !roomRef || !userId) return;

            const messageText = chatInput.value.trim();
            if (messageText === "") return;

            const newMessage = {
                senderId: userId,
                senderAlias: `User-${userId.substring(0, 4)}`, 
                text: messageText,
                timestamp: Date.now()
            };

            try {
                await updateDoc(roomRef, {
                    messages: arrayUnion(newMessage)
                });
                chatInput.value = '';
            } catch (error) {
                console.error("ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ã‚¨ãƒ©ãƒ¼:", error);
                displayMessage("ãƒãƒ£ãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®é€ä¿¡ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", 'error');
            }
        }

        function renderMessages(messages) {
            messagesList.innerHTML = '';
            
            const msgs = messages.slice(-50); 
            
            msgs.forEach(msg => {
                const isMe = msg.senderId === userId;
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                messageElement.classList.add(isMe ? 'my-message' : 'other-message');
                
                const alias = msg.senderAlias || `User-${msg.senderId.substring(0, 4)}`;
                const time = new Date(msg.timestamp).toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });

                messageElement.innerHTML = `
                    <div class="message-header">
                        <span class="sender">${isMe ? 'ç§' : alias}</span>
                        <span class="time">${time}</span>
                    </div>
                    <div class="message-content">${msg.text}</div>
                `;
                messagesList.appendChild(messageElement);
            });
            messagesList.scrollTop = messagesList.scrollHeight;
        }
        
        function endGame(winnerId) {
            drawButton.disabled = true;
            checkButton.disabled = true;
            discardSelectedButton.style.display = 'none';
            ponButton.style.display = 'none';

            if (winnerId) {
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚å‹è€…: ${winnerId === userId ? 'ã‚ãªãŸ' : 'ç›¸æ‰‹'}`;
                 connectionStatus.style.backgroundColor = winnerId === userId ? '#00FF00' : '#FF0000';
            } else {
                 connectionStatus.textContent = `ã‚²ãƒ¼ãƒ çµ‚äº†ã€‚`;
                 connectionStatus.style.backgroundColor = '#AAAAAA';
            }
            
            if (unsubscribeRoom) {
                 unsubscribeRoom();
                 unsubscribeRoom = null;
            }
            setTimeout(() => {
                location.reload(); 
            }, 3000);
        }
        
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        
        // -----------------------------------------------------
        // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
        // -----------------------------------------------------

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('create-room-button').addEventListener('click', createRoom);
            document.getElementById('join-room-button').addEventListener('click', () => joinRoom());
            document.getElementById('start-game-button').addEventListener('click', startGame);
            drawButton.onclick = drawTile;
            checkButton.onclick = checkHandForYaku;
            discardSelectedButton.onclick = discardSelectedTile;
            
            // ãƒãƒ³ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©
            ponButton.onclick = executePon;
            document.getElementById('skip-pon-button').onclick = skipPon;
            
            sendButton.addEventListener('click', sendMessage);
            chatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            
            initFirebase();
        });

    </script>
    <style>
        :root {
            --tile-bg: #fff;
            --tile-border: #333;
            --deck-bg: #556B2F; /* Olive Drab */
            --player-bg: #f4f4f9;
            --primary-color: #003366; /* Deep Blue (Baseball theme) */
            --secondary-color: #CC3333; /* Red (Baseball theme) */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f0f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 1200px;
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            padding: 20px;
            box-sizing: border-box;
        }

        h1 {
            text-align: center;
            color: var(--primary-color);
            margin-top: 0;
            font-weight: 700;
            letter-spacing: 2px;
            border-bottom: 3px solid var(--secondary-color);
            padding-bottom: 10px;
        }

        #game-container {
            display: none;
            gap: 20px;
            flex-wrap: wrap;
        }

        #game-content {
            flex-grow: 1;
            min-width: 450px;
        }
        
        /* ç‰Œã®åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ« */
        .tile {
            width: 45px;
            height: 60px;
            background-color: var(--tile-bg);
            border: 2px solid var(--tile-border);
            border-radius: 6px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: 700;
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s, box-shadow 0.1s;
        }

        .tile:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }
        
        /* ç‰Œã®è‰²ä»˜ã‘ */
        .tile[data-type^="P1"] { color: #009999; background-color: #E0FFFF; } 
        .tile[data-type^="P2"] { color: #8B4513; background-color: #F5F5DC; } 
        .tile[data-type^="P3"] { color: #006400; background-color: #90EE90; } 
        .tile[data-type^="P4"] { color: #DAA520; background-color: #FAFAD2; } 
        .tile[data-type^="P5"] { color: #FF4500; background-color: #FFDAB9; } 
        .tile[data-type^="P6"] { color: #4169E1; background-color: #ADD8E6; } 
        .tile[data-type^="P7"] { color: #800080; background-color: #E6E6FA; } 
        .tile[data-type^="P8"] { color: #2F4F4F; background-color: #D3D3D3; } 
        .tile[data-type^="P9"] { color: #B8860B; background-color: #F0E68C; } 
        
        /* å¤§è°·ç‰Œ (ã‚ªãƒ¼ãƒ«ãƒã‚¤ãƒ†ã‚£) - ç”»åƒè¡¨ç¤º */
        .tile[data-type^="OT"] { 
            color: transparent; 
            background-color: #FFD700; /* Gold */
            border-color: var(--primary-color);
            font-size: 0; 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            /* å¤§è°·é¸æ‰‹ã®ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ç¤ºã™ãŸã‚ã®ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ç”»åƒ */
            background-image: url('https://placehold.co/45x60/FFD700/003366?text=OHTANI');
        }
        
        /* è£è¿”ã—ã®ç‰Œï¼ˆå±±æœ­/ç›¸æ‰‹æ‰‹ç‰Œï¼‰ */
        .tile.face-down {
            background-color: var(--deck-bg);
            border-color: #333;
            color: transparent;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3);
            cursor: default;
        }
        .tile.face-down:hover { transform: none; box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.3); }

        /* å…¬é–‹ç‰Œã®è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ« */
        .open-tiles-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 5px 0;
            min-height: 70px;
        }
        .open-tile-set {
            display: flex;
            margin-right: 15px; /* ã‚»ãƒƒãƒˆé–“ã®ã‚¹ãƒšãƒ¼ã‚¹ */
            border: 1px dashed #666;
            padding: 2px;
            border-radius: 4px;
        }
        .open-tile-set .tile {
            cursor: default;
            transform: none;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }


        /* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
        .board-area {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .discard-area, .deck-area {
            flex-basis: 48%;
            padding: 10px;
            border-radius: 8px;
            background-color: #e0e0e0;
            text-align: center;
        }

        .discard-list {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 70px;
            justify-content: center;
        }
        
        .deck-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            background-color: #d0e0d0;
        }

        .hand-area {
            background-color: var(--player-bg);
            padding: 15px;
            border-radius: 12px;
            border: 1px solid #ccc;
            margin-bottom: 15px;
        }

        .tile-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            min-height: 70px;
        }

        /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #002244; transform: translateY(-1px); }
        .btn-secondary { background-color: var(--secondary-color); color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #a32727; transform: translateY(-1px); }
        
        .btn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }
        
        .tile.selected {
            border: 4px solid var(--secondary-color);
            box-shadow: 0 0 10px var(--secondary-color);
            transform: translateY(-5px);
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */
        #message-box {
            text-align: center;
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 700;
            min-height: 30px;
        }
        .message-success { background-color: #e6ffe6; color: var(--secondary-color); border: 1px solid var(--secondary-color); }
        .message-error { background-color: #ffe6e6; color: var(--primary-color); border: 1px solid var(--primary-color); }
        .message-normal { background-color: #f0f8ff; color: #444; border: 1px solid #aaa; }
        
        #connection-status {
            text-align: center;
            padding: 5px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 700;
            margin-bottom: 10px;
            color: white;
            background-color: #ccc;
        }
        
        /* ãƒ­ãƒ“ãƒ¼ç”»é¢ */
        #lobby-container {
            text-align: center;
            display: none;
        }
        /* ... (ãƒ­ãƒ“ãƒ¼CSSã¯å¤‰æ›´ãªã—) ... */
        
        /* --- ãƒãƒ£ãƒƒãƒˆã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« --- */
        #chat-container {
            width: 300px;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            border: 1px solid #ddd;
            border-radius: 12px;
            background-color: #f8f8f8;
            padding: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        #messages-list {
            flex-grow: 1;
            height: 400px;
            overflow-y: auto;
            margin-bottom: 10px;
            padding-right: 5px;
            scroll-behavior: smooth;
        }
        /* ... (ãƒãƒ£ãƒƒãƒˆCSSã¯å¤‰æ›´ãªã—) ... */
        
        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
        @media (max-width: 800px) {
            #game-container {
                flex-direction: column;
            }
            #chat-container {
                width: 100%;
                margin-top: 20px;
                max-height: 300px;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Firebaseãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ  é‡çƒãƒ‰ãƒ³ã‚¸ãƒ£ãƒ© (2äººå¯¾æˆ¦ï¼†ãƒãƒ£ãƒƒãƒˆ)</h1>
    <p id="loading-message" style="text-align: center; font-weight: bold;">èªè¨¼ä¸­...</p>
    
    <!-- ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
    <div id="lobby-container">
        <div id="connection-status">åŒæœŸå¾…æ©Ÿä¸­...</div>
        <div class="input-group">
            <h2 style="color: var(--secondary-color);">ãƒ«ãƒ¼ãƒ ã‚’ä½œæˆ</h2>
            <button id="create-room-button" class="btn btn-secondary">æ–°è¦ãƒ«ãƒ¼ãƒ ä½œæˆ</button>
        </div>
        <div class="input-group">
            <h2 style="color: var(--primary-color);">ãƒ«ãƒ¼ãƒ ã«å‚åŠ </h2>
            <input type="text" id="room-id-input" placeholder="ãƒ«ãƒ¼ãƒ IDã‚’å…¥åŠ›" maxlength="8">
            <button id="join-room-button" class="btn btn-primary">å‚åŠ </button>
        </div>
        <p id="user-id-display">ã‚ãªãŸã®ID: ãƒ­ãƒ¼ãƒ‰ä¸­...</p>
    </div>

    <!-- ã‚²ãƒ¼ãƒ ï¼†ãƒãƒ£ãƒƒãƒˆç”»é¢ -->
    <div id="game-container">
        
        <!-- ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚¨ãƒªã‚¢ -->
        <div id="game-content" style="display: none;">
            <h2 id="room-title" style="text-align: center; margin-bottom: 5px;"></h2>
            <p id="player-list" style="text-align: center;"></p>

            <div id="message-box"></div>
            
            <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area" style="background-color: #e6e6e6;">
                <h2 style="margin-top: 0; color: #555;">å¯¾æˆ¦ç›¸æ‰‹ã®æ‰‹ç‰Œ</h2>
                <div id="opponent-open-tiles-container" class="open-tiles-area" style="justify-content: center;">
                    <!-- ç›¸æ‰‹ã®å…¬é–‹ç‰Œ -->
                </div>
                <div id="opponent-hand-container" class="tile-list" style="justify-content: center;">
                    <!-- ç›¸æ‰‹ã®æ‰‹ç‰Œï¼ˆè£è¿”ã—ï¼‰ -->
                </div>
            </div>

            <div class="board-area">
                <!-- å±±æœ­ã‚¨ãƒªã‚¢ -->
                <div class="deck-area">
                    <p style="font-weight: 700;">å±±æœ­ (<span id="deck-count">48</span>)</p>
                    <div class="tile face-down"></div>
                </div>

                <!-- æ¨ã¦ç‰Œã‚¨ãƒªã‚¢ -->
                <div class="discard-area">
                    <p style="font-weight: 700;">æ¨ã¦ç‰Œ</p>
                    <div id="discard-container" class="discard-list">
                        <!-- æ¨ã¦ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                    </div>
                </div>
            </div>
            
            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ‰‹ç‰Œã‚¨ãƒªã‚¢ -->
            <div class="hand-area">
                <h2 style="margin-top: 0; color: #555;">ã‚ãªãŸã®æ‰‹ç‰Œ (<span id="hand-count">0</span>æš)</h2>
                <p id="current-turn" style="font-weight: bold; padding: 5px; border-radius: 4px; text-align: center;"></p>
                
                <h3 style="margin: 5px 0 5px 0; font-size: 1.1em; color: #444;">å…¬é–‹ç‰Œ (ãƒãƒ³)</h3>
                <div id="open-tiles-container" class="open-tiles-area">
                    <!-- è‡ªåˆ†ã®å…¬é–‹ç‰Œ -->
                </div>

                <h3 style="margin: 5px 0 5px 0; font-size: 1.1em; color: #444;">æ‰‹ç‰Œ</h3>
                <div id="hand-container" class="tile-list">
                    <!-- ç‰ŒãŒã“ã“ã«è¿½åŠ ã•ã‚Œã‚‹ -->
                </div>
            </div>

            <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ -->
            <div class="controls">
                <button id="draw-button" class="btn btn-primary" disabled>å±±æœ­ã‹ã‚‰1æšå¼•ã</button>
                <button id="pon-button" class="btn btn-secondary" style="display: none;">ãƒãƒ³ã™ã‚‹</button>
                <button id="skip-pon-button" class="btn" style="background-color: #888; color: white; display: none;">ã‚¹ã‚­ãƒƒãƒ—</button>
                <button id="discard-selected-button" class="btn btn-primary" style="display: none;" disabled>é¸æŠã—ãŸç‰Œã‚’æ¨ã¦ã‚‹</button>
                <button id="check-button" class="btn btn-secondary" disabled>å½¹ã‚’åˆ¤å®šã™ã‚‹</button>
                <button id="start-game-button" class="btn btn-secondary" style="display: none;">ã‚²ãƒ¼ãƒ é–‹å§‹ (ãƒ›ã‚¹ãƒˆã®ã¿)</button>
            </div>
            <button class="btn" style="background-color: #777; color: white; margin-top: 15px;" onclick="location.reload()">ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹</button>
        </div>
        
        <!-- ãƒãƒ£ãƒƒãƒˆã‚³ãƒ³ãƒ†ãƒŠ -->
        <div id="chat-container">
            <h3 style="margin-top: 0; color: #555;">ãƒ«ãƒ¼ãƒ ãƒãƒ£ãƒƒãƒˆ</h3>
            <div id="messages-list">
                <!-- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã‚‹ -->
            </div>
            <div id="chat-input-area">
                <input type="text" id="chat-input" placeholder="ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...">
                <button id="send-button" class="btn btn-secondary">é€ä¿¡</button>
            </div>
        </div>
    </div>

</div>

</body>
</html>
